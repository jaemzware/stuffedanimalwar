<!DOCTYPE html>
<html>
    <head>
        <title>{{ENDPOINT}} Camera Room</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
        <script src="/socket.io/socket.io.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                color: #fff;
                padding: 20px;
                min-height: 100vh;
            }

            .header {
                text-align: center;
                margin-bottom: 30px;
                padding: 20px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
            }

            .header h1 {
                font-size: 2em;
                margin-bottom: 10px;
                color: #fff;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            }

            .header p {
                color: #aaa;
                font-size: 0.9em;
            }

            .controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                justify-content: center;
                align-items: center;
                margin-bottom: 20px;
                padding: 15px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
            }

            .btn {
                padding: 12px 24px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 8px;
                min-width: 150px;
                justify-content: center;
            }

            .btn-camera {
                background: #666;
                color: white;
            }

            .btn-camera.active {
                background: #28a745;
            }

            .btn-camera:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }

            .btn-camera:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .checkbox-label {
                padding: 12px 20px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 10px;
                user-select: none;
                transition: all 0.3s ease;
            }

            .checkbox-label:hover {
                background: rgba(255, 255, 255, 0.15);
            }

            .checkbox-label input {
                width: 20px;
                height: 20px;
                cursor: pointer;
                accent-color: #28a745;
            }

            select {
                padding: 12px 20px;
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                font-size: 14px;
                cursor: pointer;
                min-width: 200px;
            }

            select option {
                background: #2a2a3e;
                color: white;
            }

            .status {
                text-align: center;
                padding: 10px;
                margin-bottom: 20px;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.3);
                font-size: 14px;
            }

            .status.connected {
                color: #28a745;
            }

            .status.disconnected {
                color: #dc3545;
            }

            .camera-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 15px;
                margin-bottom: 20px;
            }

            #localCameraSection {
                margin-bottom: 20px;
            }

            .camera-card {
                background: rgba(0, 0, 0, 0.5);
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                transition: transform 0.3s ease;
                position: relative;
            }

            .camera-card:hover {
                transform: translateY(-4px);
            }

            .camera-label {
                padding: 12px;
                background: rgba(0, 0, 0, 0.7);
                font-weight: 600;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .camera-label .badge {
                background: #28a745;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 700;
            }

            video {
                width: 100%;
                max-width: 100%;
                height: auto;
                display: block;
                background: #000;
                min-height: 180px;
                max-height: 300px;
                object-fit: contain;
            }

            /* Prevent fullscreen on mobile tap */
            @media (max-width: 768px) {
                video {
                    pointer-events: none;
                }

                /* Overlay to catch all touches */
                .camera-card::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 1;
                    pointer-events: auto;
                }

                .camera-label {
                    position: relative;
                    z-index: 2;
                }
            }

            .local-camera {
                border: 3px solid #28a745;
            }

            .local-camera .camera-label {
                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            }

            .empty-state {
                text-align: center;
                padding: 60px 20px;
                color: #666;
            }

            .empty-state svg {
                width: 80px;
                height: 80px;
                margin-bottom: 20px;
                opacity: 0.5;
            }

            @media (max-width: 768px) {
                .camera-grid {
                    grid-template-columns: 1fr;
                }

                .controls {
                    flex-direction: column;
                }

                .btn, select {
                    width: 100%;
                    min-width: unset;
                }
            }
        </style>
    </head>
    <body>
        <!-- Navigation Links -->
        <div style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; display: flex; gap: 10px;">
            <a id="canvasLink" href="#" style="padding: 12px 20px; background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; text-decoration: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                <span>üé®</span>
                <span>Canvas</span>
            </a>
            <a id="cameraLink" href="#" style="padding: 12px 20px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; text-decoration: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                <span>üìπ</span>
                <span>Camera</span>
            </a>
        </div>
        <script>
            // Set navigation links dynamically based on endpoint
            (function() {
                const endpoint = "{{ENDPOINT}}";
                const baseUrl = window.location.origin;
                document.getElementById('canvasLink').href = baseUrl + '/' + endpoint;
                document.getElementById('cameraLink').href = baseUrl + '/' + endpoint + 'camera';
            })();
        </script>

        <div class="header">
            <h1>üìπ {{ENDPOINT}} Camera Room</h1>
            <p>Share and view cameras with others in this room</p>
        </div>

        <div class="controls">
            <button id="cameraToggleButton" class="btn btn-camera">
                <span id="cameraIcon">üìπ</span>
                <span id="cameraLabel">Enable Camera</span>
            </button>

            <button id="cameraSwitchButton" class="btn btn-camera" disabled style="background: #666;">
                <span>üîÑ</span>
                <span>Switch Camera</span>
            </button>

            <button id="micToggleButton" class="btn btn-camera">
                <span id="micIcon">üé§</span>
                <span id="micLabel">Enable Mic</span>
            </button>

            <select id="cameraSelector">
                <option value="">Select Camera...</option>
            </select>

            <input type="text" id="cameraNameInput" placeholder="Your camera name..."
                   style="width: 100%; padding: 10px; margin: 8px 0; border: 2px solid #555; border-radius: 8px; background: #2a2a3e; color: white; font-size: 14px;">

            <label class="checkbox-label">
                <input type="checkbox" id="acceptCameraCheckbox" checked>
                <span>Show Remote Cameras</span>
            </label>

            <label class="checkbox-label">
                <input type="checkbox" id="acceptMicCheckbox">
                <span>Accept Remote Audio</span>
            </label>

            <span id="peerCount" style="color: #aaa; font-size: 13px;">Peers: 0</span>

            <button id="refreshPeersButton" class="btn btn-camera" style="margin-top: 8px; background: #17a2b8;">
                <span>üîÑ</span>
                <span>Refresh Peers</span>
            </button>

            <button id="resumeAllVideosButton" class="btn btn-camera" style="margin-top: 8px; background: #007bff;">
                <span>‚ñ∂Ô∏è</span>
                <span>Resume All Videos</span>
            </button>
        </div>

        <div id="status" class="status disconnected">
            Connecting to room...
        </div>

        <div id="localCameraSection" style="display: none; max-width: 400px;">
            <div class="camera-card local-camera">
                <div class="camera-label">
                    <span id="localCameraNameLabel">üìπ Your Camera</span>
                    <span class="badge">LOCAL</span>
                </div>
                <video id="localCameraVideo" autoplay playsinline webkit-playsinline muted disablePictureInPicture x5-playsinline x5-video-player-type="h5"></video>
            </div>
        </div>

        <div id="remoteCameraSection">
            <div id="remoteCameraGrid" class="camera-grid"></div>
            <div id="emptyState" class="empty-state">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                </svg>
                <p>No remote cameras connected</p>
                <p style="font-size: 12px; margin-top: 10px;">Other users will appear here when they enable their cameras</p>
            </div>
        </div>

        <script>
            const endpoint = "{{ENDPOINT}}";
            const socket = io({
                query: { endpoint: endpoint + 'camera' },
                transports: ['polling', 'websocket'],
                upgrade: true,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 5
            });

            // Camera and mic state
            let localCameraStream = null;
            let localMicStream = null;
            let isCameraEnabled = false;
            let isMicEnabled = false;
            // Load saved camera preference from localStorage
            let selectedCameraDeviceId = null;
            try {
                const savedDeviceId = localStorage.getItem('selectedCameraDeviceId');
                if (savedDeviceId) {
                    selectedCameraDeviceId = savedDeviceId;
                    console.log('üì∑ Loaded saved camera preference from localStorage:', savedDeviceId);
                }
            } catch (error) {
                console.warn('Could not load camera preference from localStorage:', error);
            }
            let peerConnections = {};
            let remoteCameraStreams = {};
            let isRemoteAudioMuted = true; // Start muted (acceptMicCheckbox starts unchecked)
            let pendingIceCandidates = {}; // Queue for ICE candidates that arrive before remote description
            let myCameraName = ''; // User's custom camera name
            let peerCameraNames = {}; // Map of peerId -> camera name

            // ICE servers
            const iceServers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            // Socket event names
            const voiceOfferSocketEvent = endpoint + 'cameracamera' + 'voiceoffer';
            const voiceAnswerSocketEvent = endpoint + 'cameracamera' + 'voiceanswer';
            const voiceIceCandidateSocketEvent = endpoint + 'cameracamera' + 'voiceicecandidate';
            const connectSocketEvent = endpoint + 'cameracamera' + 'connect';
            const disconnectSocketEvent = endpoint + 'cameracamera' + 'disconnect';
            const cameraNameUpdateSocketEvent = endpoint + 'cameracamera' + 'nameupdate';

            // Initialize
            document.addEventListener('DOMContentLoaded', function() {
                // Initialize checkbox state variables from HTML
                const acceptCameraCheckbox = document.getElementById('acceptCameraCheckbox');
                const acceptMicCheckbox = document.getElementById('acceptMicCheckbox');
                const remoteCameraSection = document.getElementById('remoteCameraSection');

                // Sync isRemoteAudioMuted with checkbox initial state
                isRemoteAudioMuted = !acceptMicCheckbox.checked;

                // Sync remote camera section visibility with checkbox initial state
                remoteCameraSection.style.display = acceptCameraCheckbox.checked ? 'block' : 'none';

                console.log('üé¨ Initial state - Show Remote Cameras:', acceptCameraCheckbox.checked, 'Accept Remote Audio:', acceptMicCheckbox.checked);
                console.log('üîá Remote audio muted:', isRemoteAudioMuted);

                // Set up event listeners
                document.getElementById('cameraToggleButton').addEventListener('click', toggleCamera);
                const cameraSwitchButton = document.getElementById('cameraSwitchButton');
                if (cameraSwitchButton) {
                    cameraSwitchButton.addEventListener('click', switchCamera);
                }
                document.getElementById('micToggleButton').addEventListener('click', toggleMic);
                document.getElementById('cameraSelector').addEventListener('change', handleCameraChange);
                acceptCameraCheckbox.addEventListener('change', handleAcceptCameraChange);
                acceptMicCheckbox.addEventListener('change', handleAcceptMicChange);
                document.getElementById('refreshPeersButton').addEventListener('click', refreshPeerConnections);
                document.getElementById('resumeAllVideosButton').addEventListener('click', resumeAllVideos);
                document.getElementById('cameraNameInput').addEventListener('input', function(e) {
                    myCameraName = e.target.value.trim();
                    console.log('Camera name set to:', myCameraName || '(default)');

                    // Update local camera label if camera is visible
                    const localCameraNameLabel = document.getElementById('localCameraNameLabel');
                    if (localCameraNameLabel) {
                        localCameraNameLabel.textContent = myCameraName ? `üìπ ${myCameraName}` : 'üìπ Your Camera';
                    }

                    // Broadcast name change to all connected peers
                    socket.emit(cameraNameUpdateSocketEvent, {
                        cameraName: myCameraName
                    });
                    console.log('üì§ Broadcast camera name update:', myCameraName || '(cleared)');
                });

                populateCameraDevices();
                initializeSocketHandlers();

                // Prevent video fullscreen on mobile - global handler
                document.addEventListener('touchstart', (e) => {
                    if (e.target.tagName === 'VIDEO') {
                        // Allow tap but prevent fullscreen
                        e.target.removeAttribute('controls');
                    }
                }, { passive: true });

                // Handle page visibility changes (mobile backgrounding)
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        console.log('üì± Page hidden (backgrounded) - connections may pause');
                        // Store the time when backgrounded
                        window._backgroundedAt = Date.now();
                    } else {
                        console.log('üì± Page visible again - checking connections');

                        // Calculate how long we were backgrounded
                        const backgroundDuration = window._backgroundedAt ?
                            (Date.now() - window._backgroundedAt) / 1000 : 0;
                        console.log(`‚è±Ô∏è Was backgrounded for ${backgroundDuration.toFixed(1)} seconds`);

                        // Check all peer connections and attempt recovery if needed
                        Object.keys(peerConnections).forEach(peerId => {
                            const pc = peerConnections[peerId];
                            if (pc) {
                                console.log('Peer', peerId, 'state:', pc.connectionState, 'ICE:', pc.iceConnectionState);

                                // If connection degraded while backgrounded, attempt recovery
                                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' ||
                                    pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
                                    console.log('üîÑ Attempting to recover degraded connection for peer:', peerId);
                                    attemptIceRestart(pc, peerId);
                                }
                            }
                        });

                        // Resume local video if it was paused
                        const localVideo = document.getElementById('localCameraVideo');
                        if (localVideo && localVideo.paused && localVideo.srcObject) {
                            console.log('‚ñ∂Ô∏è Resuming local video after backgrounding');
                            localVideo.play().catch(err => {
                                console.log('‚ö†Ô∏è Could not resume local video:', err);
                            });
                        }

                        // Resume all remote videos
                        document.querySelectorAll('video[id^="remoteVideoElement_"]').forEach(video => {
                            if (video.paused && video.srcObject) {
                                console.log('‚ñ∂Ô∏è Resuming remote video:', video.id);
                                video.play().catch(err => {
                                    console.log('‚ö†Ô∏è Could not resume video:', err);
                                });
                            }
                        });
                    }
                });
            });

            // Socket connection
            socket.on('connect', function() {
                console.log('Connected to room:', endpoint + 'camera');
                document.getElementById('status').textContent = 'Connected to room';
                document.getElementById('status').className = 'status connected';

                // Request roster from all existing peers to ensure full mesh connectivity
                setTimeout(() => {
                    console.log('üìã Requesting roster from existing peers');
                    socket.emit(endpoint + 'cameracamera' + 'requestroster', {
                        userId: socket.id
                    });
                }, 1000); // Small delay to let connect events propagate first

                // Start periodic presence announcements to help peers discover us
                // This helps even when peers have different code versions
                if (window.presenceInterval) {
                    clearInterval(window.presenceInterval);
                }
                window.presenceInterval = setInterval(() => {
                    // Always announce presence, even if no camera name is set
                    // This helps with peer discovery
                    console.log('üíì Heartbeat: announcing presence with name:', myCameraName || '(none)');
                    socket.emit(cameraNameUpdateSocketEvent, {
                        cameraName: myCameraName || ''
                    });
                }, 30000); // Every 30 seconds
            });

            socket.on('disconnect', function() {
                console.log('Disconnected from room');
                document.getElementById('status').textContent = 'Disconnected - reconnecting...';
                document.getElementById('status').className = 'status disconnected';
            });

            // Refresh peer connections function
            function refreshPeerConnections() {
                console.log('üîÑ Refreshing peer connections...');

                // Update button state
                const refreshButton = document.getElementById('refreshPeersButton');
                const originalHTML = refreshButton.innerHTML;
                refreshButton.innerHTML = '<span>‚è≥</span><span>Refreshing...</span>';
                refreshButton.disabled = true;

                // Close all existing peer connections and clean up
                Object.keys(peerConnections).forEach(peerId => {
                    const pc = peerConnections[peerId];
                    if (pc) {
                        // Clear quality monitor
                        if (pc._qualityMonitor) {
                            clearInterval(pc._qualityMonitor);
                        }
                        // Clear audio check interval
                        if (pc._audioCheckInterval) {
                            clearInterval(pc._audioCheckInterval);
                        }
                        pc.close();
                    }

                    // Remove video element and monitors
                    const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                    if (videoWrapper) {
                        const video = videoWrapper.querySelector('video');
                        if (video && video._renderMonitor) {
                            clearInterval(video._renderMonitor);
                        }
                        videoWrapper.remove();
                    }

                    // Remove audio element
                    const audioElement = document.getElementById('remoteAudio_' + peerId);
                    if (audioElement) {
                        audioElement.remove();
                    }
                });

                // Clear all peer connection data structures
                peerConnections = {};
                remoteCameraStreams = {};
                peerCameraNames = {};
                pendingIceCandidates = {};

                // Update UI
                updatePeerCount();
                updateEmptyState();

                console.log('‚úÖ Cleared all peer connections');

                // Wait a moment, then request all peers to reconnect
                setTimeout(() => {
                    console.log('üì¢ Broadcasting reconnection request to room');
                    console.log('Current camera name:', myCameraName || '(none)');

                    // Emit BOTH reconnect and connect events
                    // reconnect: tells peers with lower IDs to create offers to us
                    // connect: we create offers to peers with higher IDs (like when first joining)
                    socket.emit(endpoint + 'cameracamera' + 'reconnect', {
                        userId: socket.id
                    });

                    socket.emit(connectSocketEvent, {
                        userId: socket.id
                    });

                    // Request all peers to announce themselves (even those with higher IDs)
                    socket.emit(endpoint + 'cameracamera' + 'requestroster', {
                        userId: socket.id
                    });

                    console.log('üîÑ Reconnection process initiated (emitted reconnect + connect + requestroster)');

                    // Re-enable button after a delay
                    setTimeout(() => {
                        refreshButton.innerHTML = originalHTML;
                        refreshButton.disabled = false;
                    }, 2000);
                }, 500);
            }

            // Resume all videos function
            function resumeAllVideos() {
                console.log('‚ñ∂Ô∏è Resuming all videos...');

                // Update button state
                const resumeButton = document.getElementById('resumeAllVideosButton');
                const originalHTML = resumeButton.innerHTML;
                resumeButton.innerHTML = '<span>‚è≥</span><span>Resuming...</span>';
                resumeButton.disabled = true;

                let totalVideos = 0;
                let resumedVideos = 0;
                let alreadyPlayingVideos = 0;

                // Find all video elements (local + remote)
                const allVideos = document.querySelectorAll('video');
                totalVideos = allVideos.length;

                console.log(`Found ${totalVideos} video element(s)`);

                allVideos.forEach((video, index) => {
                    const videoId = video.id || `video-${index}`;
                    const isPaused = video.paused;
                    const hasSrc = !!video.srcObject;

                    console.log(`Video ${videoId}:`, {
                        paused: isPaused,
                        hasSrc: hasSrc,
                        readyState: video.readyState,
                        muted: video.muted
                    });

                    if (hasSrc) {
                        if (isPaused) {
                            // Try to resume
                            video.play().then(() => {
                                resumedVideos++;
                                console.log(`‚úÖ Resumed ${videoId}`);
                            }).catch(err => {
                                console.warn(`‚ö†Ô∏è Could not resume ${videoId}:`, err.message);
                            });
                        } else {
                            alreadyPlayingVideos++;
                            console.log(`‚úÖ ${videoId} already playing`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è ${videoId} has no video source`);
                    }
                });

                // Show results after a brief delay
                setTimeout(() => {
                    const message = `Checked ${totalVideos} video(s): ${alreadyPlayingVideos} playing, ${resumedVideos} resumed`;
                    console.log(`üìä ${message}`);

                    // Update button with result
                    if (resumedVideos > 0) {
                        resumeButton.innerHTML = `<span>‚úÖ</span><span>Resumed ${resumedVideos}</span>`;
                    } else if (alreadyPlayingVideos === totalVideos && totalVideos > 0) {
                        resumeButton.innerHTML = '<span>‚úÖ</span><span>All Playing</span>';
                    } else {
                        resumeButton.innerHTML = '<span>‚ö†Ô∏è</span><span>Check Console</span>';
                    }

                    // Reset button after 3 seconds
                    setTimeout(() => {
                        resumeButton.innerHTML = originalHTML;
                        resumeButton.disabled = false;
                    }, 3000);
                }, 500);
            }

            // Camera functions
            async function populateCameraDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    const cameraSelector = document.getElementById('cameraSelector');

                    cameraSelector.innerHTML = '<option value="">Select Camera...</option>';

                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${index + 1}`;

                        // Pre-select if this matches our selected device
                        if (device.deviceId === selectedCameraDeviceId) {
                            option.selected = true;
                        }

                        cameraSelector.appendChild(option);
                    });

                    console.log('Found', videoDevices.length, 'camera(s)', 'Selected:', selectedCameraDeviceId || 'none');
                } catch (error) {
                    console.error('Error enumerating cameras:', error);
                }
            }

            async function handleCameraChange(event) {
                const newDeviceId = event.target.value;
                console.log('Camera selection changed to:', newDeviceId);

                if (!newDeviceId) {
                    console.log('Empty device ID selected');
                    return;
                }

                selectedCameraDeviceId = newDeviceId;

                // Save to localStorage for persistence
                try {
                    localStorage.setItem('selectedCameraDeviceId', newDeviceId);
                    console.log('‚úÖ Saved camera preference to localStorage:', newDeviceId);
                } catch (error) {
                    console.warn('Could not save camera preference:', error);
                }

                // If camera is already enabled, switch to the new device
                if (isCameraEnabled) {
                    console.log('Camera already enabled, switching devices...');
                    try {
                        // Stop current stream
                        if (localCameraStream) {
                            localCameraStream.getTracks().forEach(track => track.stop());
                        }

                        // Start with new device
                        await startCamera();
                    } catch (error) {
                        console.error('Error switching camera:', error);
                        document.getElementById('status').textContent = 'Error switching camera: ' + error.message;
                        document.getElementById('status').className = 'status disconnected';
                    }
                } else {
                    console.log('Camera not yet enabled, device will be used when enabled');
                }
            }

            function handleAcceptCameraChange(event) {
                const remoteCameraSection = document.getElementById('remoteCameraSection');
                const isChecked = event.target.checked;
                remoteCameraSection.style.display = isChecked ? 'block' : 'none';
                console.log('üìπ Show Remote Cameras changed to:', isChecked, '- Section display:', remoteCameraSection.style.display);
            }

            function handleAcceptMicChange(event) {
                const isChecked = event.target.checked;
                isRemoteAudioMuted = !isChecked;
                console.log('üîä Accept Remote Audio changed to:', isChecked, '‚Üí isRemoteAudioMuted:', isRemoteAudioMuted);

                // Mute/unmute all existing remote audio elements
                const audioElements = document.querySelectorAll('audio[id^="remoteAudio_"]');
                console.log(`üîá Updating ${audioElements.length} audio element(s)`);
                audioElements.forEach(audioElement => {
                    audioElement.muted = isRemoteAudioMuted;
                    console.log('  ‚Ü≥ Set', audioElement.id, 'muted:', audioElement.muted);
                });
            }

            async function startCamera() {
                const localCameraSection = document.getElementById('localCameraSection');
                const localCameraVideo = document.getElementById('localCameraVideo');
                const cameraSelector = document.getElementById('cameraSelector');

                console.log('Starting camera with device ID:', selectedCameraDeviceId);

                // Detect if we're on mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('Device type:', isMobile ? 'Mobile' : 'Desktop');

                const constraints = {
                    video: {
                        // Lower resolution for mobile to prevent freezing
                        width: { ideal: isMobile ? 640 : 1280 },
                        height: { ideal: isMobile ? 480 : 720 },
                        // Mobile-friendly frameRate
                        frameRate: { ideal: isMobile ? 15 : 30, max: 30 }
                    }
                };

                // Use selected device if specified, otherwise let browser choose
                if (selectedCameraDeviceId) {
                    constraints.video.deviceId = { exact: selectedCameraDeviceId };
                } else {
                    constraints.video.facingMode = 'user';
                }

                console.log('getUserMedia constraints:', JSON.stringify(constraints));

                try {
                    localCameraStream = await navigator.mediaDevices.getUserMedia(constraints);

                    console.log('‚úÖ Camera stream obtained:', localCameraStream.id);
                    console.log('Video tracks:', localCameraStream.getVideoTracks().map(t => ({
                        id: t.id,
                        label: t.label,
                        enabled: t.enabled,
                        readyState: t.readyState,
                        muted: t.muted
                    })));

                    // Set the stream to the video element
                    localCameraVideo.srcObject = localCameraStream;
                    console.log('üìπ Set srcObject to video element');

                    // Show the video container
                    localCameraSection.style.display = 'block';
                    console.log('üëÅÔ∏è Made video container visible');

                    // Force the video to play
                    console.log('‚ñ∂Ô∏è Attempting to play video...');
                    try {
                        await localCameraVideo.play();
                        console.log('‚úÖ Video playing successfully');
                        console.log('Video element state:', {
                            paused: localCameraVideo.paused,
                            muted: localCameraVideo.muted,
                            readyState: localCameraVideo.readyState,
                            videoWidth: localCameraVideo.videoWidth,
                            videoHeight: localCameraVideo.videoHeight,
                            srcObject: !!localCameraVideo.srcObject
                        });

                        // Prevent fullscreen on local video
                        localCameraVideo.controls = false;
                        localCameraVideo.addEventListener('webkitbeginfullscreen', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        }, true);
                        localCameraVideo.addEventListener('webkitendfullscreen', (e) => {
                            e.preventDefault();
                        }, true);

                        // Auto-resume if local video pauses unexpectedly
                        localCameraVideo.addEventListener('pause', () => {
                            console.log('‚è∏Ô∏è Local video paused - attempting to resume');
                            setTimeout(() => {
                                if (localCameraVideo.paused && localCameraVideo.srcObject) {
                                    localCameraVideo.play().catch(err => {
                                        console.log('‚ö†Ô∏è Could not resume local video:', err);
                                    });
                                }
                            }, 100);
                        });
                    } catch (playError) {
                        console.error('‚ùå Video play error:', playError);
                    }

                    // Update dropdown to show actual device being used
                    const videoTrack = localCameraStream.getVideoTracks()[0];
                    if (videoTrack) {
                        const settings = videoTrack.getSettings();
                        console.log('Camera settings:', settings);
                        if (settings.deviceId) {
                            cameraSelector.value = settings.deviceId;
                            selectedCameraDeviceId = settings.deviceId;
                        }
                    }

                    // Listen for video metadata loaded
                    localCameraVideo.addEventListener('loadedmetadata', function() {
                        console.log('üìä Video metadata loaded:', {
                            width: localCameraVideo.videoWidth,
                            height: localCameraVideo.videoHeight
                        });
                    });

                    // Listen for video data
                    localCameraVideo.addEventListener('loadeddata', function() {
                        console.log('üì¶ Video data loaded');
                    });

                    document.getElementById('status').textContent = 'Camera active';
                    document.getElementById('status').className = 'status connected';

                    // Add or replace video tracks in all peer connections
                    Object.keys(peerConnections).forEach(async (peerId) => {
                        const pc = peerConnections[peerId];
                        if (pc && pc.connectionState === 'connected') {
                            console.log('üîÑ Updating camera track for peer:', peerId);

                            // Find existing video sender
                            const senders = pc.getSenders();
                            const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');

                            const newVideoTrack = localCameraStream.getVideoTracks()[0];

                            if (videoSender) {
                                // Replace existing video track
                                try {
                                    await videoSender.replaceTrack(newVideoTrack);
                                    console.log('‚úÖ Replaced video track for peer:', peerId);
                                } catch (err) {
                                    console.error('‚ùå Failed to replace track for peer:', peerId, err);
                                }
                            } else {
                                // No existing video track, add new one
                                pc.addTrack(newVideoTrack, localCameraStream);
                                console.log('‚ûï Added new video track for peer:', peerId);

                                // Renegotiate when adding new track
                                try {
                                    const offer = await pc.createOffer();
                                    await pc.setLocalDescription(offer);
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: peerId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent renegotiation offer to peer:', peerId);
                                } catch (err) {
                                    console.error('‚ùå Renegotiation failed for peer:', peerId, err);
                                }
                            }
                        }
                    });

                    // Refresh camera list with proper labels
                    await populateCameraDevices();

                } catch (error) {
                    console.error('Camera access error:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);

                    let errorMsg = 'Camera error: ' + error.name;
                    if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        errorMsg = 'Camera not found - check if it\'s connected';
                    } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMsg = 'Camera permission denied - check browser settings';
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        errorMsg = 'Camera in use by another app';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMsg = 'Camera doesn\'t support requested settings';
                    }

                    document.getElementById('status').textContent = errorMsg;
                    document.getElementById('status').className = 'status disconnected';
                    alert(errorMsg + '\n\nDetails: ' + error.message);
                    throw error;
                }
            }

            async function toggleCamera() {
                const button = document.getElementById('cameraToggleButton');
                const cameraSwitchButton = document.getElementById('cameraSwitchButton');
                const icon = document.getElementById('cameraIcon');
                const label = document.getElementById('cameraLabel');
                const localCameraSection = document.getElementById('localCameraSection');
                const localCameraVideo = document.getElementById('localCameraVideo');

                if (!isCameraEnabled) {
                    console.log('Enabling camera...');
                    try {
                        await startCamera();

                        button.classList.add('active');
                        label.textContent = 'Camera On';
                        isCameraEnabled = true;

                        // Enable camera switch button
                        if (cameraSwitchButton) {
                            cameraSwitchButton.disabled = false;
                            cameraSwitchButton.style.background = '#007bff';
                        }

                        console.log('Camera enabled successfully');
                    } catch (error) {
                        console.error('Failed to enable camera:', error);
                        isCameraEnabled = false;
                    }
                } else {
                    console.log('Disabling camera...');
                    if (localCameraStream) {
                        localCameraStream.getTracks().forEach(track => {
                            console.log('Stopping track:', track.label);
                            track.stop();
                        });
                        localCameraStream = null;
                    }

                    localCameraVideo.srcObject = null;
                    localCameraSection.style.display = 'none';

                    button.classList.remove('active');
                    label.textContent = 'Enable Camera';

                    isCameraEnabled = false;

                    // Disable camera switch button
                    if (cameraSwitchButton) {
                        cameraSwitchButton.disabled = true;
                        cameraSwitchButton.style.background = '#666';
                    }

                    document.getElementById('status').textContent = 'Camera disabled';
                    document.getElementById('status').className = 'status disconnected';

                    console.log('Camera disabled');
                }
            }

            async function toggleMic() {
                const button = document.getElementById('micToggleButton');
                const icon = document.getElementById('micIcon');
                const label = document.getElementById('micLabel');

                if (!isMicEnabled) {
                    console.log('Enabling microphone...');
                    try {
                        localMicStream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            }
                        });

                        console.log('‚úÖ Microphone access granted!');
                        console.log('Audio tracks:', localMicStream.getAudioTracks().map(t => ({
                            id: t.id,
                            label: t.label,
                            enabled: t.enabled,
                            readyState: t.readyState
                        })));

                        button.classList.add('active');
                        label.textContent = 'Mic On';
                        isMicEnabled = true;

                        document.getElementById('status').textContent = 'Microphone enabled';
                        document.getElementById('status').className = 'status connected';

                        // Add audio tracks to all peer connections
                        Object.keys(peerConnections).forEach(peerId => {
                            const pc = peerConnections[peerId];
                            if (pc && pc.connectionState === 'connected') {
                                console.log('üì§ Adding audio track to peer:', peerId);
                                localMicStream.getAudioTracks().forEach(track => {
                                    pc.addTrack(track, localMicStream);
                                });

                                // Renegotiate
                                pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                    .then(() => {
                                        socket.emit(voiceOfferSocketEvent, {
                                            offer: pc.localDescription,
                                            to: peerId,
                                            cameraName: myCameraName
                                        });
                                    });
                            }
                        });

                        console.log('Microphone enabled successfully');
                    } catch (error) {
                        console.error('‚ùå Microphone access error:', error);

                        let errorMsg = 'Microphone error: ' + error.name;
                        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                            errorMsg = 'Microphone not found';
                        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                            errorMsg = 'Microphone permission denied - check browser settings';
                        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                            errorMsg = 'Microphone in use by another app';
                        }

                        document.getElementById('status').textContent = errorMsg;
                        document.getElementById('status').className = 'status disconnected';
                        alert(errorMsg + '\n\nDetails: ' + error.message);
                        isMicEnabled = false;
                    }
                } else {
                    console.log('Disabling microphone...');
                    if (localMicStream) {
                        localMicStream.getTracks().forEach(track => {
                            console.log('Stopping audio track:', track.label);
                            track.stop();
                        });
                        localMicStream = null;
                    }

                    button.classList.remove('active');
                    label.textContent = 'Enable Mic';
                    isMicEnabled = false;

                    document.getElementById('status').textContent = 'Microphone disabled';
                    document.getElementById('status').className = 'status disconnected';

                    console.log('Microphone disabled');
                }
            }

            function updatePeerCount() {
                const count = Object.keys(peerConnections).length;
                document.getElementById('peerCount').textContent = 'Peers: ' + count;

                // Diagnostic: log peer connection states on Safari
                console.log('üìä Peer connections:', count);
                Object.keys(peerConnections).forEach(peerId => {
                    const pc = peerConnections[peerId];
                    const receivers = pc.getReceivers();
                    const videoReceivers = receivers.filter(r => r.track && r.track.kind === 'video');
                    const audioReceivers = receivers.filter(r => r.track && r.track.kind === 'audio');
                    console.log(`  Peer ${peerId.substring(0, 8)}:`,
                        'connection:', pc.connectionState,
                        'ice:', pc.iceConnectionState,
                        'video tracks:', videoReceivers.length,
                        'audio tracks:', audioReceivers.length);

                    // Log track states
                    videoReceivers.forEach((r, i) => {
                        console.log(`    Video ${i}:`, 'readyState:', r.track.readyState, 'muted:', r.track.muted);
                    });
                });
            }

            function updateEmptyState() {
                const remoteCameraGrid = document.getElementById('remoteCameraGrid');
                const emptyState = document.getElementById('emptyState');
                const hasRemoteCameras = remoteCameraGrid.children.length > 0;
                emptyState.style.display = hasRemoteCameras ? 'none' : 'block';
            }

            // Monitor if video element is actually rendering frames
            function monitorVideoRendering(videoElement, peerId, videoWrapper) {
                let noVideoCount = 0;
                const checkInterval = 3000; // Check every 3 seconds

                const renderMonitor = setInterval(() => {
                    // Check if video has dimensions (indicates it's loaded)
                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        // Video has dimensions, reset counter
                        noVideoCount = 0;

                        // Update badge to show resolution
                        const badge = videoWrapper.querySelector('.badge');
                        if (badge && badge.textContent === 'LIVE') {
                            // Optionally show resolution
                            // badge.textContent = `${videoElement.videoWidth}x${videoElement.videoHeight}`;
                        }
                    } else {
                        // Video element exists but has no dimensions (black screen)
                        noVideoCount++;

                        if (noVideoCount >= 3) { // 9 seconds of black screen
                            console.error(`‚¨õ Black screen detected for peer ${peerId}!`);
                            console.log('Video element state:', {
                                readyState: videoElement.readyState,
                                networkState: videoElement.networkState,
                                paused: videoElement.paused,
                                videoWidth: videoElement.videoWidth,
                                videoHeight: videoElement.videoHeight,
                                srcObject: !!videoElement.srcObject
                            });

                            // Update badge to show issue
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'NO VIDEO';
                                badge.style.background = '#000';
                                badge.style.color = '#fff';
                            }
                        }
                    }
                }, checkInterval);

                // Store monitor so we can clean it up
                videoElement._renderMonitor = renderMonitor;
            }

            // Monitor connection quality and detect frozen streams
            function monitorConnectionQuality(pc, peerId) {
                const checkInterval = 5000; // Check every 5 seconds
                let lastBytesReceived = 0;
                let noDataCount = 0;

                const qualityMonitor = setInterval(async () => {
                    if (!pc || pc.connectionState === 'closed') {
                        clearInterval(qualityMonitor);
                        return;
                    }

                    try {
                        const stats = await pc.getStats();
                        let currentBytesReceived = 0;
                        let packetsLost = 0;
                        let packetsReceived = 0;

                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                currentBytesReceived = report.bytesReceived || 0;
                                packetsLost = report.packetsLost || 0;
                                packetsReceived = report.packetsReceived || 0;
                            }
                        });

                        // Check if we're receiving data
                        if (currentBytesReceived === lastBytesReceived && currentBytesReceived > 0) {
                            noDataCount++;
                            console.warn(`‚ö†Ô∏è No new data from peer ${peerId} for ${noDataCount * checkInterval / 1000} seconds`);

                            // If frozen for 15 seconds, attempt ICE restart
                            if (noDataCount >= 3) {
                                console.error(`‚ùå Stream from peer ${peerId} appears frozen! Attempting ICE restart...`);
                                attemptIceRestart(pc, peerId);
                                noDataCount = 0; // Reset counter after restart attempt
                            }
                        } else {
                            noDataCount = 0;
                        }

                        // Log packet loss if significant
                        if (packetsReceived > 0) {
                            const lossRate = (packetsLost / (packetsLost + packetsReceived)) * 100;
                            if (lossRate > 5) {
                                console.warn(`üìä Peer ${peerId} packet loss: ${lossRate.toFixed(1)}%`);
                            }
                        }

                        lastBytesReceived = currentBytesReceived;
                    } catch (err) {
                        console.error('Error checking connection quality:', err);
                    }
                }, checkInterval);

                // Store the interval so we can clear it later
                pc._qualityMonitor = qualityMonitor;
            }

            // Attempt ICE restart to recover frozen connection
            async function attemptIceRestart(pc, peerId) {
                if (!pc || pc.connectionState === 'closed') return;

                console.log('üîÑ Attempting ICE restart for peer:', peerId);

                try {
                    // Create new offer with iceRestart option
                    const offer = await pc.createOffer({ iceRestart: true });
                    await pc.setLocalDescription(offer);

                    socket.emit(voiceOfferSocketEvent, {
                        offer: pc.localDescription,
                        to: peerId,
                        cameraName: myCameraName
                    });

                    console.log('‚úÖ ICE restart offer sent to peer:', peerId);
                } catch (err) {
                    console.error('‚ùå ICE restart failed for peer:', peerId, err);
                }
            }

            // Clean up peer connection and all associated resources
            function cleanupPeerConnection(peerId) {
                console.log('üßπ Cleaning up peer connection:', peerId);

                const pc = peerConnections[peerId];
                if (pc) {
                    // Clean up quality monitor
                    if (pc._qualityMonitor) {
                        clearInterval(pc._qualityMonitor);
                    }

                    // Close the connection
                    pc.close();
                    delete peerConnections[peerId];
                }

                // Clean up video element and monitors
                const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                if (videoWrapper) {
                    const video = videoWrapper.querySelector('video');
                    if (video && video._renderMonitor) {
                        clearInterval(video._renderMonitor);
                    }
                    videoWrapper.remove();
                }

                // Clean up audio element
                const audioElement = document.getElementById('remoteAudio_' + peerId);
                if (audioElement) {
                    audioElement.remove();
                }

                // Clean up data structures
                delete remoteCameraStreams[peerId];
                delete pendingIceCandidates[peerId];
                delete peerCameraNames[peerId];

                updatePeerCount();
                updateEmptyState();
                console.log('‚úÖ Cleanup complete for peer:', peerId);
            }

            // WebRTC functions
            function initializeSocketHandlers() {
                socket.on(endpoint + 'cameracamera' + 'voiceoffer', handleOffer);
                socket.on(endpoint + 'cameracamera' + 'voiceanswer', handleAnswer);
                socket.on(endpoint + 'cameracamera' + 'voiceicecandidate', handleIceCandidate);
                socket.on(endpoint + 'cameracamera' + 'disconnect', handlePeerDisconnect);
                socket.on(endpoint + 'cameracamera' + 'nameupdate', handleCameraNameUpdate);
                socket.on(endpoint + 'cameracamera' + 'reconnect', handlePeerReconnect);
                socket.on(endpoint + 'cameracamera' + 'requestroster', handleRosterRequest);
            }

            function handleRosterRequest(data) {
                console.log('üìã Peer requesting roster:', data.userId, '(my ID:', socket.id, ')');

                // Only respond if this is a different peer
                if (data.userId !== socket.id) {
                    console.log('üì¢ Announcing my presence to:', data.userId, 'with name:', myCameraName || '(none)');

                    // Directly create peer connection if we don't already have one
                    if (!peerConnections[data.userId]) {
                        console.log('Creating peer connection for roster requester:', data.userId);

                        const pc = createPeerConnection(data.userId);

                        // Use glare resolution to decide who creates offer
                        const shouldCreateOffer = socket.id < data.userId;
                        console.log('Glare resolution - should I create offer?', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                        if (shouldCreateOffer) {
                            // Create and send offer
                            pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                .then(() => {
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: data.userId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent offer to roster requester:', data.userId);
                                })
                                .catch(err => {
                                    console.error('‚ùå Error creating offer for roster requester:', err);
                                });
                        } else {
                            console.log('‚è∏Ô∏è Created peer connection, waiting for offer from:', data.userId);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è Already have peer connection for:', data.userId);
                    }

                    // Also send our camera name if we have one
                    if (myCameraName) {
                        socket.emit(cameraNameUpdateSocketEvent, {
                            cameraName: myCameraName
                        });
                    }
                } else {
                    console.log('‚ÑπÔ∏è Ignoring roster request from myself');
                }
            }

            function handlePeerReconnect(data) {
                console.log('üîî Peer requesting reconnection:', data.userId);

                // Only respond if this is a different peer
                if (data.userId !== socket.id) {
                    // Glare resolution: only the peer with the lower ID creates the offer
                    // This prevents both peers from sending offers simultaneously
                    const shouldCreateOffer = socket.id < data.userId;

                    console.log('Should create offer:', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                    if (shouldCreateOffer) {
                        console.log('Creating new peer connection for reconnecting peer:', data.userId);

                        // Create peer connection (will add any enabled media tracks)
                        const pc = createPeerConnection(data.userId);

                        // Send offer to the reconnecting peer
                        pc.createOffer().then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                socket.emit(voiceOfferSocketEvent, {
                                    offer: pc.localDescription,
                                    to: data.userId,
                                    cameraName: myCameraName
                                });
                                console.log('üì§ Sent offer to reconnecting peer:', data.userId);
                            })
                            .catch(err => {
                                console.error('‚ùå Error creating offer for reconnecting peer:', err);
                            });
                    } else {
                        console.log('‚è∏Ô∏è Waiting for offer from peer:', data.userId, '(they have lower ID)');
                        // Still create the peer connection so we're ready to receive their offer
                        createPeerConnection(data.userId);
                    }
                }
            }

            function handleCameraNameUpdate(data) {
                console.log('üì• Received camera name update from:', data.userId, 'name:', data.cameraName || '(cleared)');

                // Ignore updates from ourselves
                if (data.userId === socket.id) {
                    console.log('‚è≠Ô∏è Ignoring our own camera name update');
                    return;
                }

                // Store the new name
                if (data.cameraName) {
                    peerCameraNames[data.userId] = data.cameraName;
                } else {
                    delete peerCameraNames[data.userId];
                }

                // Update the video label if it exists
                const videoWrapper = document.getElementById('remoteVideo_' + data.userId);
                if (videoWrapper) {
                    const label = videoWrapper.querySelector('.camera-label span:first-child');
                    if (label) {
                        const displayName = peerCameraNames[data.userId] || `Peer ${data.userId.substring(0, 8)}`;
                        label.textContent = `üìπ ${displayName}`;
                        console.log('‚úÖ Updated video label for', data.userId, 'to:', displayName);
                    }
                } else {
                    console.log('‚ö†Ô∏è No video element found for peer:', data.userId);

                    // IMPORTANT: If we received a name update but have no peer connection,
                    // it means the peer exists but we're not connected. Try to establish connection!
                    if (!peerConnections[data.userId]) {
                        console.log('üîó Attempting to establish connection with:', data.userId);

                        const pc = createPeerConnection(data.userId);

                        // Use glare resolution to decide who creates offer
                        const shouldCreateOffer = socket.id < data.userId;
                        console.log('Glare resolution:', shouldCreateOffer ? 'I create offer' : 'I wait for offer', '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                        if (shouldCreateOffer) {
                            // Create and send offer
                            pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                .then(() => {
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: data.userId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent offer to discovered peer:', data.userId);
                                })
                                .catch(err => {
                                    console.error('‚ùå Error creating offer for discovered peer:', err);
                                });
                        } else {
                            console.log('‚è∏Ô∏è Created peer connection, waiting for offer from discovered peer:', data.userId);
                            // Request the peer to send us an offer
                            socket.emit(endpoint + 'cameracamera' + 'reconnect', {
                                userId: socket.id
                            });
                        }
                    }
                }
            }

            function createPeerConnection(peerId) {
                if (peerConnections[peerId]) {
                    return peerConnections[peerId];
                }

                const pc = new RTCPeerConnection(iceServers);
                peerConnections[peerId] = pc;

                console.log('Creating peer connection for:', peerId);

                // Add local camera tracks if enabled
                if (localCameraStream) {
                    localCameraStream.getTracks().forEach(track => {
                        console.log('Adding camera track to peer:', peerId, 'kind:', track.kind);
                        pc.addTrack(track, localCameraStream);
                    });
                }

                // Add local microphone tracks if enabled
                if (localMicStream) {
                    localMicStream.getTracks().forEach(track => {
                        console.log('Adding mic track to peer:', peerId, 'kind:', track.kind);
                        pc.addTrack(track, localMicStream);
                    });
                }

                pc.onicecandidate = function(event) {
                    if (event.candidate) {
                        socket.emit(voiceIceCandidateSocketEvent, {
                            candidate: event.candidate,
                            to: peerId
                        });
                    }
                };

                pc.ontrack = function(event) {
                    console.log('üì• Received track from peer:', peerId, 'kind:', event.track.kind, 'readyState:', event.track.readyState, 'muted:', event.track.muted);
                    console.log('   Track ID:', event.track.id, 'Streams:', event.streams.length);

                    if (event.track.kind === 'video') {
                        const acceptCameraCheckbox = document.getElementById('acceptCameraCheckbox');
                        if (!acceptCameraCheckbox.checked) {
                            console.log('Video track rejected - camera checkbox not checked');
                            return;
                        }

                        const remoteCameraGrid = document.getElementById('remoteCameraGrid');
                        let videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        let isNewVideoElement = false;

                        if (!videoWrapper) {
                            isNewVideoElement = true;
                            videoWrapper = document.createElement('div');
                            videoWrapper.id = 'remoteVideo_' + peerId;
                            videoWrapper.className = 'camera-card';

                            const label = document.createElement('div');
                            label.className = 'camera-label';
                            const displayName = peerCameraNames[peerId] || `Peer ${peerId.substring(0, 8)}`;
                            label.innerHTML = `<span>üìπ ${displayName}</span><span class="badge">LIVE</span>`;

                            const video = document.createElement('video');
                            video.id = 'remoteVideoElement_' + peerId;
                            video.autoplay = true;
                            video.playsinline = true;
                            video.muted = true; // Mute to help autoplay on mobile
                            video.setAttribute('webkit-playsinline', '');
                            video.setAttribute('disablePictureInPicture', '');
                            video.setAttribute('x5-playsinline', ''); // Android WeChat
                            video.setAttribute('x5-video-player-type', 'h5');
                            video.setAttribute('x-webkit-airplay', 'allow');

                            // Prevent default video controls and fullscreen
                            video.controls = false;
                            video.addEventListener('webkitbeginfullscreen', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }, true);
                            video.addEventListener('webkitendfullscreen', (e) => {
                                e.preventDefault();
                            }, true);

                            videoWrapper.appendChild(label);
                            videoWrapper.appendChild(video);
                            remoteCameraGrid.appendChild(videoWrapper);

                            // Auto-resume if video pauses unexpectedly
                            video.addEventListener('pause', () => {
                                console.log('‚è∏Ô∏è Video paused unexpectedly for peer:', peerId, '- attempting to resume');
                                setTimeout(() => {
                                    if (video.paused && video.srcObject) {
                                        video.play().catch(err => {
                                            console.log('‚ö†Ô∏è Could not resume video for peer:', peerId, err);
                                        });
                                    }
                                }, 100);
                            });

                            console.log('‚úÖ Created video element for peer:', peerId);
                        }

                        // Get the video element (whether new or existing)
                        const video = videoWrapper.querySelector('video');

                        // Update or set the stream (handles both new tracks and renegotiation)
                        if (video.srcObject !== event.streams[0]) {
                            console.log('üîÑ Updating video stream for peer:', peerId);

                            // Clean up old render monitor if exists
                            if (video._renderMonitor) {
                                clearInterval(video._renderMonitor);
                            }

                            video.srcObject = event.streams[0];
                            remoteCameraStreams[peerId] = event.streams[0];

                            // Force play
                            video.play().catch(err => {
                                console.log('‚ö†Ô∏è Autoplay prevented for peer:', peerId, err);
                            });
                        } else {
                            console.log('‚ÑπÔ∏è Same stream already assigned for peer:', peerId);
                        }

                        // Only monitor video rendering if this is a new element
                        if (isNewVideoElement) {
                            monitorVideoRendering(video, peerId, videoWrapper);
                        }

                        // Monitor video track state
                        event.track.onended = function() {
                            console.warn('‚ö†Ô∏è Video track ended for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'OFFLINE';
                                badge.style.background = '#dc3545';
                            }
                        };

                        event.track.onmute = function() {
                            console.warn('üîá Video track muted for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'PAUSED';
                                badge.style.background = '#ffc107';
                            }
                        };

                        event.track.onunmute = function() {
                            console.log('üîä Video track unmuted for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'LIVE';
                                badge.style.background = '#28a745';
                            }
                        };

                        // Monitor stream state
                        event.streams[0].onactive = function() {
                            console.log('‚úÖ Stream became active for peer:', peerId);
                        };

                        event.streams[0].oninactive = function() {
                            console.warn('‚ö†Ô∏è Stream became inactive for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'INACTIVE';
                                badge.style.background = '#6c757d';
                            }
                        };

                        updateEmptyState();
                    } else if (event.track.kind === 'audio') {
                        console.log('üé§ Received audio track from peer:', peerId);

                        // Create or get audio element for this peer
                        let audioElement = document.getElementById('remoteAudio_' + peerId);
                        if (!audioElement) {
                            audioElement = document.createElement('audio');
                            audioElement.id = 'remoteAudio_' + peerId;
                            audioElement.autoplay = true;
                            audioElement.muted = isRemoteAudioMuted;
                            audioElement.volume = 1.0;
                            audioElement.style.display = 'none';
                            document.body.appendChild(audioElement);
                            console.log('‚úÖ Created audio element:', audioElement.id, 'muted:', audioElement.muted);
                        }

                        audioElement.srcObject = event.streams[0];

                        // Try to play audio
                        audioElement.play().then(() => {
                            console.log('‚úÖ Audio playing from peer:', peerId);
                        }).catch(err => {
                            console.warn('‚ö†Ô∏è Audio autoplay blocked:', err.message);
                        });
                    }
                };

                pc.onconnectionstatechange = function() {
                    console.log('Peer', peerId, 'connection state:', pc.connectionState);

                    if (pc.connectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è Peer disconnected:', peerId, '- will attempt recovery');
                        // Mark connection as degraded but don't clean up yet
                        const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        if (videoWrapper) {
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'RECONNECTING';
                                badge.style.background = '#ffc107';
                            }
                        }

                        // Initialize recovery counter if not exists
                        if (!pc._recoveryAttempts) {
                            pc._recoveryAttempts = 0;
                        }

                        // Attempt recovery after a brief delay
                        if (pc._recoveryAttempts < 3) {
                            pc._recoveryAttempts++;
                            setTimeout(() => {
                                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                                    console.log(`üîÑ Recovery attempt ${pc._recoveryAttempts}/3 for peer:`, peerId);
                                    attemptIceRestart(pc, peerId);
                                }
                            }, 2000 * pc._recoveryAttempts); // Exponential backoff
                        } else {
                            console.error('‚ùå Max recovery attempts reached for peer:', peerId);
                            cleanupPeerConnection(peerId);
                        }

                    } else if (pc.connectionState === 'failed') {
                        console.error('‚ùå Peer connection failed:', peerId, '- attempting ICE restart');
                        attemptIceRestart(pc, peerId);

                    } else if (pc.connectionState === 'closed') {
                        console.log('üîí Peer connection closed:', peerId);
                        cleanupPeerConnection(peerId);

                    } else if (pc.connectionState === 'connected') {
                        // Reset recovery counter on successful connection
                        pc._recoveryAttempts = 0;
                        pc._isEstablished = true; // Mark as established for renegotiation
                        updatePeerCount();
                        console.log('‚úÖ Peer connected:', peerId);

                        // Update badge to show connected
                        const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        if (videoWrapper) {
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge && badge.textContent === 'RECONNECTING') {
                                badge.textContent = 'LIVE';
                                badge.style.background = '#28a745';
                            }
                        }

                        // Monitor connection quality
                        if (!pc._qualityMonitor) {
                            monitorConnectionQuality(pc, peerId);
                        }
                    }
                };

                // Monitor ICE connection state for mobile issues
                pc.oniceconnectionstatechange = function() {
                    console.log('Peer', peerId, 'ICE connection state:', pc.iceConnectionState);
                    if (pc.iceConnectionState === 'failed') {
                        console.error('‚ùå ICE connection failed for peer:', peerId);
                    } else if (pc.iceConnectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è ICE disconnected for peer:', peerId);
                    } else if (pc.iceConnectionState === 'connected') {
                        console.log('‚úÖ ICE connected for peer:', peerId);
                    } else if (pc.iceConnectionState === 'completed') {
                        console.log('‚úÖ ICE gathering completed for peer:', peerId);
                    }
                };

                // Monitor ICE gathering state
                pc.onicegatheringstatechange = function() {
                    console.log('Peer', peerId, 'ICE gathering state:', pc.iceGatheringState);
                    if (pc.iceGatheringState === 'complete') {
                        console.log('‚úÖ ICE gathering complete for peer:', peerId);
                    }
                };

                // Monitor signaling state
                pc.onsignalingstatechange = function() {
                    console.log('Peer', peerId, 'signaling state:', pc.signalingState);
                    if (pc.signalingState === 'stable') {
                        console.log('‚úÖ Signaling stable for peer:', peerId);
                    } else if (pc.signalingState === 'closed') {
                        console.log('üîí Signaling closed for peer:', peerId);
                    }
                };

                // Monitor negotiation needed
                pc.onnegotiationneeded = async function() {
                    console.log('üîÑ Negotiation needed for peer:', peerId);
                    // Only handle if we're stable and this is a renegotiation
                    if (pc.signalingState === 'stable' && pc._isEstablished) {
                        try {
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            socket.emit(voiceOfferSocketEvent, {
                                offer: pc.localDescription,
                                to: peerId,
                                cameraName: myCameraName
                            });
                            console.log('üì§ Sent renegotiation offer to peer:', peerId);
                        } catch (err) {
                            console.error('‚ùå Renegotiation failed for peer:', peerId, err);
                        }
                    }
                };

                return pc;
            }

            async function handleOffer(data) {
                console.log('Received offer from:', data.from);

                // Store peer's camera name if provided
                if (data.cameraName) {
                    peerCameraNames[data.from] = data.cameraName;
                    console.log('üìù Stored camera name for', data.from, ':', data.cameraName);
                }

                const pc = createPeerConnection(data.from);

                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    console.log('‚úÖ Set remote description for offer from:', data.from);

                    // Process any pending ICE candidates
                    await processPendingIceCandidates(data.from);

                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);

                    socket.emit(voiceAnswerSocketEvent, {
                        answer: pc.localDescription,
                        to: data.from,
                        cameraName: myCameraName
                    });
                    console.log('üì§ Sent answer to:', data.from);
                } catch (error) {
                    console.error('‚ùå Error handling offer from:', data.from, error.message);
                    console.debug('Offer data:', data.offer);
                }
            }

            async function handleAnswer(data) {
                console.log('Received answer from:', data.from);

                // Store peer's camera name if provided
                if (data.cameraName) {
                    peerCameraNames[data.from] = data.cameraName;
                    console.log('üìù Stored camera name for', data.from, ':', data.cameraName);
                }

                const pc = peerConnections[data.from];
                if (pc) {
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        console.log('‚úÖ Set remote description for answer from:', data.from);

                        // Process any pending ICE candidates
                        await processPendingIceCandidates(data.from);
                    } catch (error) {
                        console.error('‚ùå Error handling answer from:', data.from, error.message);
                        console.debug('Answer data:', data.answer);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Received answer from unknown peer:', data.from);
                }
            }

            async function handleIceCandidate(data) {
                const pc = peerConnections[data.from];
                if (!pc || !data.candidate) return;

                // Validate candidate has required properties
                if (!data.candidate.candidate || data.candidate.candidate.trim() === '') {
                    console.warn('‚ö†Ô∏è Skipping invalid/empty ICE candidate from:', data.from);
                    return;
                }

                // If remote description not set yet, queue the candidate
                if (!pc.remoteDescription || !pc.remoteDescription.type) {
                    console.log('‚è∏Ô∏è Queueing ICE candidate from:', data.from, '(remote description not set)');
                    if (!pendingIceCandidates[data.from]) {
                        pendingIceCandidates[data.from] = [];
                    }
                    pendingIceCandidates[data.from].push(data.candidate);
                    return;
                }

                // Remote description is set, add candidate
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (error) {
                    // Safari can be strict about candidate format - log but don't crash
                    console.warn('‚ö†Ô∏è Failed to add ICE candidate from:', data.from, 'Error:', error.message);
                    console.debug('Candidate data:', data.candidate);
                }
            }

            async function processPendingIceCandidates(peerId) {
                const pc = peerConnections[peerId];
                const candidates = pendingIceCandidates[peerId];

                if (!pc || !candidates || candidates.length === 0) return;

                console.log('üîÑ Processing', candidates.length, 'pending ICE candidates for:', peerId);

                for (const candidate of candidates) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to add pending ICE candidate:', error.message);
                    }
                }

                // Clear the queue
                delete pendingIceCandidates[peerId];
                console.log('‚úÖ Processed all pending ICE candidates for:', peerId);
            }

            function handlePeerDisconnect(data) {
                console.log('Peer disconnected:', data.userId);

                // Clean up video element and monitors
                const videoWrapper = document.getElementById('remoteVideo_' + data.userId);
                if (videoWrapper) {
                    const video = videoWrapper.querySelector('video');
                    if (video && video._renderMonitor) {
                        clearInterval(video._renderMonitor);
                    }
                    videoWrapper.remove();
                }

                // Clean up audio element
                const audioElement = document.getElementById('remoteAudio_' + data.userId);
                if (audioElement) {
                    audioElement.remove();
                }

                // Close and remove peer connection
                if (peerConnections[data.userId]) {
                    peerConnections[data.userId].close();
                    delete peerConnections[data.userId];
                }

                // Clean up pending ICE candidates
                if (pendingIceCandidates[data.userId]) {
                    delete pendingIceCandidates[data.userId];
                }

                // Clean up peer camera name
                if (peerCameraNames[data.userId]) {
                    delete peerCameraNames[data.userId];
                }

                delete remoteCameraStreams[data.userId];
                updatePeerCount();
                updateEmptyState();
            }

            // Broadcast offer when new peer joins (always establish connection)
            socket.on(endpoint + 'cameracamera' + 'connect', function(data) {
                console.log('üîî New peer joined:', data.userId);

                // Only create connection if this is a different peer
                if (data.userId !== socket.id) {
                    // Glare resolution: only the peer with the lower ID creates the offer
                    // This prevents both peers from sending offers simultaneously when joining at the same time
                    const shouldCreateOffer = socket.id < data.userId;

                    console.log('Creating peer connection (camera:', isCameraEnabled, 'mic:', isMicEnabled, ')');
                    console.log('My camera name:', myCameraName || '(not set)');
                    console.log('Should create offer:', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                    if (shouldCreateOffer) {
                        // Create peer connection (will add any enabled media tracks)
                        const pc = createPeerConnection(data.userId);

                        // Always create and send offer, even if we don't have media yet
                        // This establishes the connection, and media can be added later
                        pc.createOffer().then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                socket.emit(voiceOfferSocketEvent, {
                                    offer: pc.localDescription,
                                    to: data.userId,
                                    cameraName: myCameraName
                                });
                                console.log('üì§ Sent offer to new peer:', data.userId, 'with name:', myCameraName || '(default)');
                            })
                            .catch(err => {
                                console.error('‚ùå Error creating offer:', err);
                            });
                    } else {
                        console.log('‚è∏Ô∏è Waiting for offer from peer:', data.userId, '(they have lower ID)');
                        // Still create the peer connection so we're ready to receive their offer
                        createPeerConnection(data.userId);
                    }
                }
            });
        </script>
    </body>
</html>
