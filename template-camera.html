<!DOCTYPE html>
<html>
    <head>
        <title>{{ENDPOINT}} Camera Room</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
        <script src="/socket.io/socket.io.js"></script>
        <style>
            @keyframes pulse {
                0%, 100% { transform: translateX(-50%) scale(1); }
                50% { transform: translateX(-50%) scale(1.05); }
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                color: #fff;
                padding: 10px;
                min-height: 100vh;
            }

            /* Desktop: sidebar layout */
            .page-container {
                display: flex;
                gap: 15px;
                min-height: calc(100vh - 60px);
            }

            .sidebar {
                width: 280px;
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .main-content {
                flex: 1;
                min-width: 0;
            }

            .header {
                text-align: left;
                margin-bottom: 10px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
            }

            .header h1 {
                font-size: 1.2em;
                margin: 0;
                color: #fff;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            }

            .controls {
                display: flex;
                flex-direction: column;
                gap: 8px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
            }

            .btn {
                padding: 8px 12px;
                border: none;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 6px;
                justify-content: center;
                width: 100%;
            }

            .btn-camera {
                background: #666;
                color: white;
            }

            .btn-camera.active {
                background: #28a745;
            }

            .btn-camera:hover:not(:disabled) {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }

            .btn-camera:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .checkbox-label {
                padding: 6px 10px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 6px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 6px;
                user-select: none;
                transition: all 0.2s ease;
                font-size: 11px;
            }

            .checkbox-label:hover {
                background: rgba(255, 255, 255, 0.15);
            }

            .checkbox-label input {
                width: 14px;
                height: 14px;
                cursor: pointer;
                accent-color: #28a745;
            }

            select {
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                font-size: 12px;
                cursor: pointer;
                width: 100%;
            }

            select option {
                background: #2a2a3e;
                color: white;
            }

            .control-group {
                background: rgba(255,255,255,0.05);
                padding: 8px;
                border-radius: 6px;
            }

            .control-group-label {
                color: #888;
                font-size: 10px;
                text-transform: uppercase;
                margin-bottom: 6px;
                letter-spacing: 0.5px;
            }

            .control-row {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .control-row .btn {
                flex: 1;
            }

            .status {
                text-align: center;
                padding: 10px;
                margin-bottom: 20px;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.3);
                font-size: 14px;
            }

            .status.connected {
                color: #28a745;
            }

            .status.disconnected {
                color: #dc3545;
            }

            .camera-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 15px;
                margin-bottom: 20px;
            }

            #localCameraSection {
                margin-bottom: 20px;
            }

            .camera-card {
                background: rgba(0, 0, 0, 0.5);
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                transition: transform 0.3s ease;
                position: relative;
            }

            .camera-card:hover {
                transform: translateY(-4px);
            }

            .camera-label {
                padding: 12px;
                background: rgba(0, 0, 0, 0.7);
                font-weight: 600;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .camera-label .badge {
                background: #28a745;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 700;
            }

            video {
                width: 100%;
                max-width: 100%;
                height: auto;
                display: block;
                background: #000;
                min-height: 180px;
                max-height: 300px;
                object-fit: contain;
            }

            /* Prevent fullscreen on mobile tap */
            @media (max-width: 768px) {
                video {
                    pointer-events: none;
                }

                /* Overlay to catch all touches */
                .camera-card::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 1;
                    pointer-events: auto;
                }

                .camera-label {
                    position: relative;
                    z-index: 2;
                }
            }

            .local-camera {
                border: 3px solid #28a745;
            }

            .local-camera .camera-label {
                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            }

            .empty-state {
                text-align: center;
                padding: 60px 20px;
                color: #666;
            }

            .empty-state svg {
                width: 80px;
                height: 80px;
                margin-bottom: 20px;
                opacity: 0.5;
            }

            /* Diagnostic overlay for peer videos */
            .peer-diagnostics {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.85);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 10px;
                padding: 6px 8px;
                display: none;
                z-index: 10;
                max-height: 120px;
                overflow-y: auto;
            }

            .peer-diagnostics.visible {
                display: block;
            }

            .peer-diagnostics div {
                margin: 2px 0;
                white-space: nowrap;
            }

            .peer-diagnostics .label {
                color: #888;
            }

            .peer-diagnostics .value {
                color: #0f0;
            }

            .peer-diagnostics .warn {
                color: #ffc107;
            }

            .peer-diagnostics .error {
                color: #dc3545;
            }

            /* Peer video action buttons */
            .peer-actions {
                position: absolute;
                top: 44px;
                right: 8px;
                display: flex;
                gap: 4px;
                z-index: 15;
            }

            .peer-action-btn {
                width: 28px;
                height: 28px;
                border: none;
                border-radius: 4px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                cursor: pointer;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .peer-action-btn:hover {
                background: rgba(0, 0, 0, 0.8);
                transform: scale(1.1);
            }

            .peer-action-btn.active {
                background: rgba(40, 167, 69, 0.8);
            }

            .peer-action-btn:disabled {
                opacity: 0.3;
                cursor: not-allowed;
                transform: none;
            }

            .peer-action-btn:disabled:hover {
                background: rgba(0, 0, 0, 0.6);
                transform: none;
            }

            /* Local camera action buttons */
            .local-actions {
                position: absolute;
                top: 44px;
                right: 8px;
                display: flex;
                gap: 4px;
                z-index: 15;
            }

            /* Maximized video overlay */
            .video-maximized-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.95);
                z-index: 9999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .video-maximized-overlay video {
                max-width: 95vw;
                max-height: 85vh;
                object-fit: contain;
            }

            .video-maximized-overlay .maximize-header {
                position: absolute;
                top: 10px;
                left: 0;
                right: 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 20px;
                color: white;
            }

            .video-maximized-overlay .maximize-title {
                font-size: 18px;
                font-weight: bold;
            }

            .video-maximized-overlay .maximize-close {
                width: 40px;
                height: 40px;
                border: none;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.2);
                color: white;
                cursor: pointer;
                font-size: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .video-maximized-overlay .maximize-close:hover {
                background: rgba(255, 255, 255, 0.4);
                transform: scale(1.1);
            }

            .video-maximized-overlay .maximize-info {
                position: absolute;
                bottom: 20px;
                color: rgba(255, 255, 255, 0.7);
                font-size: 14px;
            }

            /* Mobile: stacked layout with cameras at bottom */
            @media (max-width: 768px) {
                .page-container {
                    flex-direction: column;
                }

                .sidebar {
                    width: 100%;
                    order: 1;
                }

                .main-content {
                    order: 2;
                }

                .camera-grid {
                    grid-template-columns: 1fr;
                }

                .header h1 {
                    font-size: 1em;
                    text-align: center;
                }

                .btn {
                    padding: 6px 10px;
                    font-size: 11px;
                }

                .checkbox-label {
                    padding: 5px 8px;
                    font-size: 10px;
                }

                .checkbox-label input {
                    width: 12px;
                    height: 12px;
                }

                .control-group {
                    padding: 6px;
                }

                .control-group-label {
                    font-size: 9px;
                    margin-bottom: 4px;
                }

                select {
                    padding: 6px 8px;
                    font-size: 11px;
                }
            }

            /* Mobile portrait: even more compact */
            @media (max-width: 768px) and (orientation: portrait) {
                body {
                    padding: 5px;
                }

                .page-container {
                    gap: 8px;
                }

                .sidebar {
                    gap: 6px;
                }

                .controls {
                    padding: 6px;
                    gap: 6px;
                }

                .control-row {
                    gap: 4px;
                }

                .btn {
                    padding: 5px 8px;
                    font-size: 10px;
                    gap: 4px;
                }

                .checkbox-label {
                    padding: 4px 6px;
                    font-size: 9px;
                    gap: 4px;
                }

                .header {
                    padding: 6px;
                    margin-bottom: 6px;
                }

                .header h1 {
                    font-size: 0.9em;
                }
            }
        </style>
    </head>
    <body>
        <!-- PASSWORD MODAL -->
        <div id="passwordModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 99999; justify-content: center; align-items: center;">
            <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 40px; border-radius: 12px; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.5); max-width: 400px; width: 90%;">
                <h2 style="color: #fff; margin: 0 0 20px 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">Enter Room Password</h2>
                <input type="password" id="passwordInput" placeholder="Password" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #444; border-radius: 6px; background: #2a2a4a; color: #fff; box-sizing: border-box; margin-bottom: 15px;" onkeypress="if(event.key==='Enter')checkPassword()">
                <button onclick="checkPassword()" style="width: 100%; padding: 12px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer;">Enter</button>
                <p id="passwordError" style="color: #ff6b6b; margin: 15px 0 0 0; display: none;">Incorrect password</p>
            </div>
        </div>
        <script>
            const roomPassword = '{{PASSWORD}}';
            const storageKey = 'saw_auth_' + '{{ENDPOINT}}';

            function checkPassword() {
                const input = document.getElementById('passwordInput').value;
                if (input === roomPassword) {
                    sessionStorage.setItem(storageKey, 'true');
                    document.getElementById('passwordModal').style.display = 'none';
                } else {
                    document.getElementById('passwordError').style.display = 'block';
                    document.getElementById('passwordInput').value = '';
                }
            }

            // Check if already authenticated or no password required
            if (roomPassword && sessionStorage.getItem(storageKey) !== 'true') {
                document.getElementById('passwordModal').style.display = 'flex';
            }
        </script>
        <!-- Navigation Links -->
        <div style="margin-bottom: 10px; display: flex; gap: 8px;">
            <a id="canvasLink" href="#" style="padding: 6px 12px; background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; text-decoration: none; display: flex; align-items: center; gap: 4px;">
                <span>üé®</span><span>Canvas</span>
            </a>
            <a id="cameraLink" href="#" style="padding: 6px 12px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; text-decoration: none; display: flex; align-items: center; gap: 4px;">
                <span>üìπ</span><span>Camera</span>
            </a>
        </div>
        <script>
            (function() {
                const endpoint = "{{ENDPOINT}}";
                const baseUrl = window.location.origin;
                document.getElementById('canvasLink').href = baseUrl + '/' + endpoint;
                document.getElementById('cameraLink').href = baseUrl + '/' + endpoint + 'camera';
            })();
        </script>

        <div class="page-container">
            <!-- Sidebar: Controls -->
            <div class="sidebar">
                <div class="header">
                    <h1>üìπ {{ENDPOINT}} Camera Room</h1>
                </div>

                <div class="controls">
                    <!-- Your Name - Prominent -->
                    <div class="control-group">
                        <div class="control-group-label">Your Name</div>
                        <input type="text" id="cameraNameInput" placeholder="Enter your name..."
                               style="width: 100%; padding: 8px; border: 2px solid #28a745; border-radius: 6px; background: #2a2a3e; color: white; font-size: 14px; font-weight: 600;">
                    </div>

                    <!-- Video Controls -->
                    <div class="control-group">
                        <div class="control-group-label">Video</div>
                        <div class="control-row">
                            <button id="cameraToggleButton" class="btn btn-camera">
                                <span id="cameraIcon">üìπ</span>
                                <span id="cameraLabel">Camera</span>
                            </button>
                            <button id="cameraSwitchButton" class="btn btn-camera" disabled style="background: #666; flex: 0 0 auto; width: auto; padding: 8px;">
                                <span>üîÑ</span>
                            </button>
                        </div>
                        <label class="checkbox-label" style="margin-top: 6px;">
                            <input type="checkbox" id="acceptCameraCheckbox" checked>
                            <span>Show Remote Cameras</span>
                        </label>
                        <select id="cameraSelector" style="margin-top: 6px;">
                            <option value="">Select Camera...</option>
                        </select>
                    </div>

                    <!-- Audio Controls -->
                    <div class="control-group">
                        <div class="control-group-label">Audio</div>
                        <button id="micToggleButton" class="btn btn-camera">
                            <span id="micIcon">üé§</span>
                            <span id="micLabel">Mic</span>
                        </button>
                        <label class="checkbox-label" style="margin-top: 6px;">
                            <input type="checkbox" id="acceptMicCheckbox">
                            <span>Accept Remote Audio</span>
                        </label>
                    </div>

                    <!-- Status & Utilities -->
                    <div class="control-group">
                        <div class="control-group-label">Connection</div>
                        <div id="status" class="status disconnected" style="margin: 0 0 6px 0; padding: 6px; font-size: 11px;">
                            Connecting...
                        </div>
                        <span id="peerCount" style="color: #aaa; font-size: 11px; display: block; margin-bottom: 6px;">Peers: 0</span>
                        <div class="control-row">
                            <button id="refreshPeersButton" class="btn btn-camera" style="background: #17a2b8;">
                                <span>üîÑ</span>
                            </button>
                            <button id="resumeAllVideosButton" class="btn btn-camera" style="background: #007bff;">
                                <span>‚ñ∂Ô∏è</span>
                            </button>
                            <button id="showLogsButton" class="btn btn-camera" style="background: #6c757d;">
                                <span>üìã</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Local Camera Preview in Sidebar -->
                <div id="localCameraSection" style="display: none;">
                    <div class="camera-card local-camera">
                        <div class="camera-label">
                            <span id="localCameraNameLabel">üìπ You</span>
                            <span class="badge">LOCAL</span>
                        </div>
                        <div class="local-actions">
                            <button class="peer-action-btn" onclick="maximizeVideo('localCameraVideo', 'Your Camera')" title="Maximize">‚õ∂</button>
                        </div>
                        <video id="localCameraVideo" autoplay playsinline webkit-playsinline muted disablePictureInPicture x5-playsinline x5-video-player-type="h5"></video>
                    </div>
                </div>
            </div>

            <!-- Main Content: Remote Cameras -->
            <div class="main-content">
                <div id="remoteCameraSection">
                    <div id="remoteCameraGrid" class="camera-grid"></div>
                    <div id="emptyState" class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                        </svg>
                        <p>No remote cameras connected</p>
                        <p style="font-size: 11px; margin-top: 8px;">Others will appear here when they enable cameras</p>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Console log capture for mobile debugging
            const capturedLogs = [];
            const MAX_LOGS = 200;
            const originalConsole = {
                log: console.log,
                warn: console.warn,
                error: console.error
            };

            function captureLog(type, args) {
                const timestamp = new Date().toLocaleTimeString();
                const message = Array.from(args).map(arg => {
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');

                capturedLogs.push({ timestamp, type, message });

                // Keep only last MAX_LOGS entries
                if (capturedLogs.length > MAX_LOGS) {
                    capturedLogs.shift();
                }
            }

            console.log = function(...args) {
                captureLog('log', args);
                originalConsole.log.apply(console, args);
            };

            console.warn = function(...args) {
                captureLog('warn', args);
                originalConsole.warn.apply(console, args);
            };

            console.error = function(...args) {
                captureLog('error', args);
                originalConsole.error.apply(console, args);
            };

            // Safe play function that prevents iOS fullscreen
            function safePlayVideo(video) {
                if (!video) return Promise.reject(new Error('No video element'));

                // Ensure all anti-fullscreen attributes are set
                video.setAttribute('playsinline', '');
                video.setAttribute('webkit-playsinline', '');
                video.setAttribute('disablePictureInPicture', '');
                video.setAttribute('x5-playsinline', '');
                video.setAttribute('x5-video-player-type', 'h5');
                video.playsInline = true;
                video.controls = false;
                video.muted = true; // Must be muted for autoplay on iOS

                return video.play();
            }

            // Maximize video to fullscreen overlay
            function maximizeVideo(videoId, title) {
                const video = document.getElementById(videoId);
                if (!video || !video.srcObject) {
                    console.warn('Cannot maximize - no video source');
                    return;
                }

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'video-maximized-overlay';
                overlay.id = 'maximizeOverlay';

                // Header with title and close button
                const header = document.createElement('div');
                header.className = 'maximize-header';

                const titleEl = document.createElement('span');
                titleEl.className = 'maximize-title';
                titleEl.textContent = 'üìπ ' + title;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'maximize-close';
                closeBtn.innerHTML = '‚úï';
                closeBtn.title = 'Close (Esc)';
                closeBtn.onclick = closeMaximize;

                header.appendChild(titleEl);
                header.appendChild(closeBtn);

                // Clone the video stream to a new video element
                const maxVideo = document.createElement('video');
                maxVideo.autoplay = true;
                maxVideo.playsinline = true;
                maxVideo.setAttribute('webkit-playsinline', '');
                maxVideo.muted = video.muted;
                maxVideo.srcObject = video.srcObject;

                // Info footer
                const info = document.createElement('div');
                info.className = 'maximize-info';
                info.textContent = 'Press Esc or tap √ó to close';

                overlay.appendChild(header);
                overlay.appendChild(maxVideo);
                overlay.appendChild(info);

                // Add to body
                document.body.appendChild(overlay);

                // Play the video
                maxVideo.play().catch(err => console.warn('Maximize video play error:', err));

                // Update info with resolution when available
                maxVideo.addEventListener('loadedmetadata', () => {
                    if (maxVideo.videoWidth && maxVideo.videoHeight) {
                        info.textContent = `${maxVideo.videoWidth}√ó${maxVideo.videoHeight} ‚Ä¢ Press Esc or tap √ó to close`;
                    }
                });

                // Close on Escape key
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeMaximize();
                    }
                };
                document.addEventListener('keydown', escHandler);
                overlay._escHandler = escHandler;

                // Close on background click
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        closeMaximize();
                    }
                });

                console.log('üîç Maximized video:', title);
            }

            function closeMaximize() {
                const overlay = document.getElementById('maximizeOverlay');
                if (overlay) {
                    if (overlay._escHandler) {
                        document.removeEventListener('keydown', overlay._escHandler);
                    }
                    overlay.remove();
                    console.log('üîç Closed maximized view');
                }
            }

            function showLogs() {
                // Create or get log overlay
                let overlay = document.getElementById('logOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'logOverlay';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.95);
                        z-index: 10000;
                        overflow-y: auto;
                        padding: 10px;
                        font-family: 'Courier New', monospace;
                        font-size: 11px;
                    `;

                    const header = document.createElement('div');
                    header.style.cssText = `
                        position: sticky;
                        top: 0;
                        background: #333;
                        padding: 10px;
                        margin: -10px -10px 10px -10px;
                        display: flex;
                        gap: 10px;
                        flex-wrap: wrap;
                    `;

                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = '‚úï Close';
                    closeBtn.style.cssText = 'padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;';
                    closeBtn.onclick = () => overlay.remove();

                    const copyBtn = document.createElement('button');
                    copyBtn.textContent = 'üìã Copy All';
                    copyBtn.style.cssText = 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;';
                    copyBtn.onclick = () => {
                        const text = capturedLogs.map(l => `[${l.timestamp}] ${l.type.toUpperCase()}: ${l.message}`).join('\n');
                        navigator.clipboard.writeText(text).then(() => {
                            copyBtn.textContent = '‚úì Copied!';
                            setTimeout(() => copyBtn.textContent = 'üìã Copy All', 2000);
                        }).catch(() => {
                            // Fallback for older browsers
                            const ta = document.createElement('textarea');
                            ta.value = text;
                            document.body.appendChild(ta);
                            ta.select();
                            document.execCommand('copy');
                            document.body.removeChild(ta);
                            copyBtn.textContent = '‚úì Copied!';
                            setTimeout(() => copyBtn.textContent = 'üìã Copy All', 2000);
                        });
                    };

                    const clearBtn = document.createElement('button');
                    clearBtn.textContent = 'üóë Clear';
                    clearBtn.style.cssText = 'padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;';
                    clearBtn.onclick = () => {
                        capturedLogs.length = 0;
                        document.getElementById('logContent').innerHTML = '<div style="color: #666;">Logs cleared</div>';
                    };

                    const countSpan = document.createElement('span');
                    countSpan.style.cssText = 'color: #aaa; padding: 8px; align-self: center;';
                    countSpan.id = 'logCount';

                    header.appendChild(closeBtn);
                    header.appendChild(copyBtn);
                    header.appendChild(clearBtn);
                    header.appendChild(countSpan);

                    const logContent = document.createElement('div');
                    logContent.id = 'logContent';

                    overlay.appendChild(header);
                    overlay.appendChild(logContent);
                    document.body.appendChild(overlay);
                }

                // Update count
                document.getElementById('logCount').textContent = `${capturedLogs.length} logs`;

                // Populate logs
                const logContent = document.getElementById('logContent');
                logContent.innerHTML = capturedLogs.map(l => {
                    let color = '#0f0';
                    if (l.type === 'warn') color = '#ffc107';
                    if (l.type === 'error') color = '#dc3545';
                    return `<div style="color: ${color}; margin: 2px 0; word-break: break-all;">[${l.timestamp}] ${l.message}</div>`;
                }).join('');

                // Scroll to bottom
                logContent.scrollTop = logContent.scrollHeight;
            }

            const endpoint = "{{ENDPOINT}}";
            const socket = io({
                query: { endpoint: endpoint + 'camera' },
                transports: ['polling', 'websocket'],
                upgrade: true,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 5
            });

            // Camera and mic state
            let localCameraStream = null;
            let localMicStream = null;
            let isCameraEnabled = false;
            let isMicEnabled = false;
            // Load saved camera preference from localStorage
            let selectedCameraDeviceId = null;
            try {
                const savedDeviceId = localStorage.getItem('selectedCameraDeviceId');
                if (savedDeviceId) {
                    selectedCameraDeviceId = savedDeviceId;
                    console.log('üì∑ Loaded saved camera preference from localStorage:', savedDeviceId);
                }
            } catch (error) {
                console.warn('Could not load camera preference from localStorage:', error);
            }
            let peerConnections = {};
            let remoteCameraStreams = {};
            let isRemoteAudioMuted = true; // Start muted (acceptMicCheckbox starts unchecked)
            let pendingIceCandidates = {}; // Queue for ICE candidates that arrive before remote description
            let myCameraName = ''; // User's custom camera name
            let peerCameraNames = {}; // Map of peerId -> camera name
            let peerAudioMuted = {}; // Map of peerId -> boolean (true = muted)
            let lastPeerCount = 0; // Track peer count for notifications

            // ICE servers (STUN + TURN for NAT traversal)
            const iceServers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    // OpenRelay free TURN servers (provided by Metered.ca)
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                iceCandidatePoolSize: 10  // Pre-gather candidates to speed up connection
            };

            // Socket event names
            const voiceOfferSocketEvent = endpoint + 'cameracamera' + 'voiceoffer';
            const voiceAnswerSocketEvent = endpoint + 'cameracamera' + 'voiceanswer';
            const voiceIceCandidateSocketEvent = endpoint + 'cameracamera' + 'voiceicecandidate';
            const connectSocketEvent = endpoint + 'cameracamera' + 'connect';
            const disconnectSocketEvent = endpoint + 'cameracamera' + 'disconnect';
            const cameraNameUpdateSocketEvent = endpoint + 'cameracamera' + 'nameupdate';

            // Initialize
            document.addEventListener('DOMContentLoaded', function() {
                // Initialize checkbox state variables from HTML
                const acceptCameraCheckbox = document.getElementById('acceptCameraCheckbox');
                const acceptMicCheckbox = document.getElementById('acceptMicCheckbox');
                const remoteCameraSection = document.getElementById('remoteCameraSection');

                // Sync isRemoteAudioMuted with checkbox initial state
                isRemoteAudioMuted = !acceptMicCheckbox.checked;

                // Sync remote camera section visibility with checkbox initial state
                remoteCameraSection.style.display = acceptCameraCheckbox.checked ? 'block' : 'none';

                console.log('üé¨ Initial state - Show Remote Cameras:', acceptCameraCheckbox.checked, 'Accept Remote Audio:', acceptMicCheckbox.checked);
                console.log('üîá Remote audio muted:', isRemoteAudioMuted);

                // Set up event listeners
                document.getElementById('cameraToggleButton').addEventListener('click', toggleCamera);
                const cameraSwitchButton = document.getElementById('cameraSwitchButton');
                if (cameraSwitchButton) {
                    cameraSwitchButton.addEventListener('click', switchCamera);
                }
                document.getElementById('micToggleButton').addEventListener('click', toggleMic);
                document.getElementById('cameraSelector').addEventListener('change', handleCameraChange);
                acceptCameraCheckbox.addEventListener('change', handleAcceptCameraChange);
                acceptMicCheckbox.addEventListener('change', handleAcceptMicChange);
                document.getElementById('refreshPeersButton').addEventListener('click', refreshPeerConnections);
                document.getElementById('resumeAllVideosButton').addEventListener('click', resumeAllVideos);
                document.getElementById('showLogsButton').addEventListener('click', showLogs);
                document.getElementById('cameraNameInput').addEventListener('input', function(e) {
                    myCameraName = e.target.value.trim();
                    console.log('Camera name set to:', myCameraName || '(default)');

                    // Update local camera label if camera is visible
                    const localCameraNameLabel = document.getElementById('localCameraNameLabel');
                    if (localCameraNameLabel) {
                        localCameraNameLabel.textContent = myCameraName ? `üìπ ${myCameraName}` : 'üìπ Your Camera';
                    }

                    // Broadcast name change to all connected peers
                    socket.emit(cameraNameUpdateSocketEvent, {
                        cameraName: myCameraName
                    });
                    console.log('üì§ Broadcast camera name update:', myCameraName || '(cleared)');
                });

                populateCameraDevices();
                initializeSocketHandlers();

                // Prevent video fullscreen on mobile - global handler
                document.addEventListener('touchstart', (e) => {
                    if (e.target.tagName === 'VIDEO') {
                        // Allow tap but prevent fullscreen
                        e.target.removeAttribute('controls');
                    }
                }, { passive: true });

                // Handle page visibility changes (mobile backgrounding)
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        console.log('üì± Page hidden (backgrounded) - connections may pause');
                        // Store the time when backgrounded
                        window._backgroundedAt = Date.now();
                    } else {
                        console.log('üì± Page visible again - checking connections');

                        // Calculate how long we were backgrounded
                        const backgroundDuration = window._backgroundedAt ?
                            (Date.now() - window._backgroundedAt) / 1000 : 0;
                        console.log(`‚è±Ô∏è Was backgrounded for ${backgroundDuration.toFixed(1)} seconds`);

                        // Check all peer connections and attempt recovery if needed
                        Object.keys(peerConnections).forEach(peerId => {
                            const pc = peerConnections[peerId];
                            if (pc) {
                                console.log('Peer', peerId, 'state:', pc.connectionState, 'ICE:', pc.iceConnectionState);

                                // If connection degraded while backgrounded, attempt recovery
                                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' ||
                                    pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
                                    console.log('üîÑ Attempting to recover degraded connection for peer:', peerId);
                                    attemptIceRestart(pc, peerId);
                                }
                            }
                        });

                        // Resume local video if it was paused
                        const localVideo = document.getElementById('localCameraVideo');
                        if (localVideo && localVideo.paused && localVideo.srcObject) {
                            console.log('‚ñ∂Ô∏è Resuming local video after backgrounding');
                            localVideo.play().catch(err => {
                                console.log('‚ö†Ô∏è Could not resume local video:', err);
                            });
                        }

                        // Resume all remote videos
                        document.querySelectorAll('video[id^="remoteVideoElement_"]').forEach(video => {
                            if (video.paused && video.srcObject) {
                                console.log('‚ñ∂Ô∏è Resuming remote video:', video.id);
                                video.play().catch(err => {
                                    console.log('‚ö†Ô∏è Could not resume video:', err);
                                });
                            }
                        });
                    }
                });
            });

            // Socket connection
            socket.on('connect', function() {
                console.log('Connected to room:', endpoint + 'camera');
                document.getElementById('status').textContent = 'Connected to room';
                document.getElementById('status').className = 'status connected';

                // Request roster from all existing peers to ensure full mesh connectivity
                setTimeout(() => {
                    console.log('üìã Requesting roster from existing peers');
                    socket.emit(endpoint + 'cameracamera' + 'requestroster', {
                        userId: socket.id
                    });
                }, 1000); // Small delay to let connect events propagate first

                // Start periodic presence announcements to help peers discover us
                // This helps even when peers have different code versions
                if (window.presenceInterval) {
                    clearInterval(window.presenceInterval);
                }
                window.presenceInterval = setInterval(() => {
                    // Always announce presence, even if no camera name is set
                    // This helps with peer discovery
                    console.log('üíì Heartbeat: announcing presence with name:', myCameraName || '(none)');
                    socket.emit(cameraNameUpdateSocketEvent, {
                        cameraName: myCameraName || ''
                    });
                }, 30000); // Every 30 seconds
            });

            socket.on('disconnect', function() {
                console.log('Disconnected from room');
                document.getElementById('status').textContent = 'Disconnected - reconnecting...';
                document.getElementById('status').className = 'status disconnected';
            });

            // Refresh peer connections function
            function refreshPeerConnections() {
                console.log('üîÑ Refreshing peer connections...');

                // Update button state
                const refreshButton = document.getElementById('refreshPeersButton');
                const originalHTML = refreshButton.innerHTML;
                refreshButton.innerHTML = '<span>‚è≥</span><span>Refreshing...</span>';
                refreshButton.disabled = true;

                // Close all existing peer connections and clean up
                Object.keys(peerConnections).forEach(peerId => {
                    const pc = peerConnections[peerId];
                    if (pc) {
                        // Clear quality monitor
                        if (pc._qualityMonitor) {
                            clearInterval(pc._qualityMonitor);
                        }
                        // Clear audio check interval
                        if (pc._audioCheckInterval) {
                            clearInterval(pc._audioCheckInterval);
                        }
                        pc.close();
                    }

                    // Remove video element and monitors
                    const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                    if (videoWrapper) {
                        const video = videoWrapper.querySelector('video');
                        if (video) {
                            if (video._renderMonitor) {
                                clearInterval(video._renderMonitor);
                            }
                            if (video._diagInterval) {
                                clearInterval(video._diagInterval);
                            }
                        }
                        videoWrapper.remove();
                    }

                    // Remove audio element
                    const audioElement = document.getElementById('remoteAudio_' + peerId);
                    if (audioElement) {
                        audioElement.remove();
                    }
                });

                // Clear all peer connection data structures
                peerConnections = {};
                remoteCameraStreams = {};
                peerCameraNames = {};
                pendingIceCandidates = {};

                // Update UI
                updatePeerCount();
                updateEmptyState();

                console.log('‚úÖ Cleared all peer connections');

                // Wait a moment, then request all peers to reconnect
                setTimeout(() => {
                    console.log('üì¢ Broadcasting reconnection request to room');
                    console.log('Current camera name:', myCameraName || '(none)');

                    // Store a list to track which peers respond
                    window._refreshPeerList = new Set();

                    // Request all peers to announce themselves
                    socket.emit(endpoint + 'cameracamera' + 'requestroster', {
                        userId: socket.id
                    });

                    // Wait a bit for roster responses, then force reconnection
                    setTimeout(() => {
                        console.log('üîÑ Forcing reconnection to all known peers');

                        // Emit reconnect to tell others to connect to us
                        socket.emit(endpoint + 'cameracamera' + 'reconnect', {
                            userId: socket.id
                        });

                        // Also emit connect so we actively try to connect to them
                        // This ensures bidirectional connection attempts
                        socket.emit(connectSocketEvent, {
                            userId: socket.id
                        });

                        console.log('üîÑ Reconnection process initiated (emitted requestroster + reconnect + connect)');
                    }, 500);

                    // Re-enable button after a delay
                    setTimeout(() => {
                        refreshButton.innerHTML = originalHTML;
                        refreshButton.disabled = false;
                    }, 2500);
                }, 500);
            }

            // Resume all videos function
            function resumeAllVideos() {
                console.log('‚ñ∂Ô∏è Resuming all videos...');

                // Update button state
                const resumeButton = document.getElementById('resumeAllVideosButton');
                const originalHTML = resumeButton.innerHTML;
                resumeButton.innerHTML = '<span>‚è≥</span><span>Resuming...</span>';
                resumeButton.disabled = true;

                let totalVideos = 0;
                let resumedVideos = 0;
                let alreadyPlayingVideos = 0;

                // Find all video elements (local + remote)
                const allVideos = document.querySelectorAll('video');
                totalVideos = allVideos.length;

                console.log(`Found ${totalVideos} video element(s)`);

                allVideos.forEach((video, index) => {
                    const videoId = video.id || `video-${index}`;
                    const isPaused = video.paused;
                    const hasSrc = !!video.srcObject;

                    console.log(`Video ${videoId}:`, {
                        paused: isPaused,
                        hasSrc: hasSrc,
                        readyState: video.readyState,
                        muted: video.muted
                    });

                    if (hasSrc) {
                        if (isPaused) {
                            // Try to resume safely without triggering fullscreen
                            safePlayVideo(video).then(() => {
                                resumedVideos++;
                                console.log(`‚úÖ Resumed ${videoId}`);
                            }).catch(err => {
                                console.warn(`‚ö†Ô∏è Could not resume ${videoId}:`, err.message);
                            });
                        } else {
                            alreadyPlayingVideos++;
                            console.log(`‚úÖ ${videoId} already playing`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è ${videoId} has no video source`);
                    }
                });

                // Show results after a brief delay
                setTimeout(() => {
                    const message = `Checked ${totalVideos} video(s): ${alreadyPlayingVideos} playing, ${resumedVideos} resumed`;
                    console.log(`üìä ${message}`);

                    // Update button with result
                    if (resumedVideos > 0) {
                        resumeButton.innerHTML = `<span>‚úÖ</span><span>Resumed ${resumedVideos}</span>`;
                    } else if (alreadyPlayingVideos === totalVideos && totalVideos > 0) {
                        resumeButton.innerHTML = '<span>‚úÖ</span><span>All Playing</span>';
                    } else {
                        resumeButton.innerHTML = '<span>‚ö†Ô∏è</span><span>Check Console</span>';
                    }

                    // Reset button after 3 seconds
                    setTimeout(() => {
                        resumeButton.innerHTML = originalHTML;
                        resumeButton.disabled = false;
                    }, 3000);
                }, 500);
            }

            // Camera functions
            async function populateCameraDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    const cameraSelector = document.getElementById('cameraSelector');

                    cameraSelector.innerHTML = '<option value="">Select Camera...</option>';

                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${index + 1}`;

                        // Pre-select if this matches our selected device
                        if (device.deviceId === selectedCameraDeviceId) {
                            option.selected = true;
                        }

                        cameraSelector.appendChild(option);
                    });

                    console.log('Found', videoDevices.length, 'camera(s)', 'Selected:', selectedCameraDeviceId || 'none');
                } catch (error) {
                    console.error('Error enumerating cameras:', error);
                }
            }

            async function handleCameraChange(event) {
                const newDeviceId = event.target.value;
                console.log('Camera selection changed to:', newDeviceId);

                if (!newDeviceId) {
                    console.log('Empty device ID selected');
                    return;
                }

                selectedCameraDeviceId = newDeviceId;

                // Save to localStorage for persistence
                try {
                    localStorage.setItem('selectedCameraDeviceId', newDeviceId);
                    console.log('‚úÖ Saved camera preference to localStorage:', newDeviceId);
                } catch (error) {
                    console.warn('Could not save camera preference:', error);
                }

                // If camera is already enabled, switch to the new device
                if (isCameraEnabled) {
                    console.log('Camera already enabled, switching devices...');
                    try {
                        // Stop current stream
                        if (localCameraStream) {
                            localCameraStream.getTracks().forEach(track => track.stop());
                        }

                        // Start with new device
                        await startCamera();
                    } catch (error) {
                        console.error('Error switching camera:', error);
                        document.getElementById('status').textContent = 'Error switching camera: ' + error.message;
                        document.getElementById('status').className = 'status disconnected';
                    }
                } else {
                    console.log('Camera not yet enabled, device will be used when enabled');
                }
            }

            function handleAcceptCameraChange(event) {
                const remoteCameraSection = document.getElementById('remoteCameraSection');
                const isChecked = event.target.checked;
                remoteCameraSection.style.display = isChecked ? 'block' : 'none';
                console.log('üìπ Show Remote Cameras changed to:', isChecked, '- Section display:', remoteCameraSection.style.display);
            }

            function handleAcceptMicChange(event) {
                const isChecked = event.target.checked;
                isRemoteAudioMuted = !isChecked;
                console.log('üîä Accept Remote Audio changed to:', isChecked, '‚Üí isRemoteAudioMuted:', isRemoteAudioMuted);

                // Mute/unmute all existing remote audio elements
                const audioElements = document.querySelectorAll('audio[id^="remoteAudio_"]');
                console.log(`üîá Updating ${audioElements.length} audio element(s)`);
                audioElements.forEach(audioElement => {
                    audioElement.muted = isRemoteAudioMuted;
                    console.log('  ‚Ü≥ Set', audioElement.id, 'muted:', audioElement.muted);

                    // If unmuting, try to play in case browser paused it
                    if (!isRemoteAudioMuted) {
                        audioElement.play().catch(err => {
                            console.warn('‚ö†Ô∏è Could not resume audio:', audioElement.id, err.message);
                        });
                    }
                });

                // Update all per-peer state and button icons (based on video elements, not audio)
                const videoWrappers = document.querySelectorAll('[id^="remoteVideo_"]');
                console.log(`üîä Updating ${videoWrappers.length} peer button(s)`);
                videoWrappers.forEach(wrapper => {
                    const peerId = wrapper.id.replace('remoteVideo_', '');
                    peerAudioMuted[peerId] = isRemoteAudioMuted;
                    const audioBtn = document.getElementById('audioBtn_' + peerId);
                    // Only update icon/title for enabled buttons (peers with audio)
                    if (audioBtn && !audioBtn.disabled) {
                        audioBtn.innerHTML = isRemoteAudioMuted ? 'üîá' : 'üîä';
                        audioBtn.title = isRemoteAudioMuted ? 'Unmute this peer' : 'Mute this peer';
                    }
                });
            }

            function togglePeerAudio(peerId) {
                const audioElement = document.getElementById('remoteAudio_' + peerId);
                const audioBtn = document.getElementById('audioBtn_' + peerId);

                // Toggle the muted state
                const newMutedState = !peerAudioMuted[peerId];
                peerAudioMuted[peerId] = newMutedState;

                // Update audio element if it exists
                if (audioElement) {
                    audioElement.muted = newMutedState;
                    console.log('üîä Toggled audio for peer:', peerId, '‚Üí muted:', newMutedState);

                    // If unmuting, try to play in case browser paused it
                    if (!newMutedState) {
                        audioElement.play().then(() => {
                            console.log('üîä Audio resumed for peer:', peerId);
                        }).catch(err => {
                            console.warn('‚ö†Ô∏è Could not resume audio for peer:', peerId, err.message);
                        });
                    }
                } else {
                    console.log('üîä Set audio mute state for peer:', peerId, '‚Üí muted:', newMutedState, '(audio element not yet created)');
                }

                // Update button icon
                if (audioBtn) {
                    audioBtn.innerHTML = newMutedState ? 'üîá' : 'üîä';
                    audioBtn.title = newMutedState ? 'Unmute this peer' : 'Mute this peer';
                }
            }

            async function startCamera() {
                const localCameraSection = document.getElementById('localCameraSection');
                const localCameraVideo = document.getElementById('localCameraVideo');
                const cameraSelector = document.getElementById('cameraSelector');

                console.log('Starting camera with device ID:', selectedCameraDeviceId);

                // Detect if we're on mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('Device type:', isMobile ? 'Mobile' : 'Desktop');

                // Build constraints - use 'ideal' to allow fallback if camera doesn't support
                const constraints = {
                    video: {
                        // Use 'ideal' so browser can negotiate if camera doesn't support
                        width: { ideal: isMobile ? 640 : 1280 },
                        height: { ideal: isMobile ? 480 : 720 },
                        frameRate: { ideal: isMobile ? 15 : 30 }
                    }
                };

                // Use selected device if specified, otherwise let browser choose
                if (selectedCameraDeviceId) {
                    // Use 'ideal' instead of 'exact' to allow fallback
                    constraints.video.deviceId = { ideal: selectedCameraDeviceId };
                } else {
                    constraints.video.facingMode = { ideal: 'user' };
                }

                console.log('getUserMedia constraints:', JSON.stringify(constraints));

                // First check if any cameras exist on this device
                let hasCamera = false;
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    hasCamera = devices.some(device => device.kind === 'videoinput');
                    console.log('üì∑ Camera detection:', hasCamera ? 'Camera(s) found' : 'No cameras detected');
                } catch (enumError) {
                    console.warn('‚ö†Ô∏è Could not enumerate devices:', enumError.message);
                }

                if (!hasCamera) {
                    const noCameraMsg = 'No camera detected on this device';
                    console.error('‚ùå', noCameraMsg);
                    document.getElementById('status').textContent = noCameraMsg;
                    document.getElementById('status').className = 'status disconnected';
                    alert(noCameraMsg + '\n\nThis device can still view remote cameras and use the microphone.');
                    throw new Error(noCameraMsg);
                }

                // Try with constraints first, fall back to basic video if it fails
                let stream = null;
                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (constraintError) {
                    console.warn('‚ö†Ô∏è Constraints failed, trying basic video:', constraintError.message);

                    // Fallback: try with just the device ID if specified
                    if (selectedCameraDeviceId) {
                        try {
                            stream = await navigator.mediaDevices.getUserMedia({
                                video: { deviceId: { ideal: selectedCameraDeviceId } }
                            });
                        } catch (deviceError) {
                            console.warn('‚ö†Ô∏è Device selection failed, trying any camera:', deviceError.message);
                        }
                    }

                    // Last resort: just request any video
                    if (!stream) {
                        stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    }
                }

                try {
                    localCameraStream = stream;

                    console.log('‚úÖ Camera stream obtained:', localCameraStream.id);
                    console.log('Video tracks:', localCameraStream.getVideoTracks().map(t => ({
                        id: t.id,
                        label: t.label,
                        enabled: t.enabled,
                        readyState: t.readyState,
                        muted: t.muted
                    })));

                    // Set the stream to the video element
                    localCameraVideo.srcObject = localCameraStream;
                    console.log('üìπ Set srcObject to video element');

                    // Show the video container
                    localCameraSection.style.display = 'block';
                    console.log('üëÅÔ∏è Made video container visible');

                    // Force the video to play
                    console.log('‚ñ∂Ô∏è Attempting to play video...');
                    try {
                        await localCameraVideo.play();
                        console.log('‚úÖ Video playing successfully');
                        console.log('Video element state:', {
                            paused: localCameraVideo.paused,
                            muted: localCameraVideo.muted,
                            readyState: localCameraVideo.readyState,
                            videoWidth: localCameraVideo.videoWidth,
                            videoHeight: localCameraVideo.videoHeight,
                            srcObject: !!localCameraVideo.srcObject
                        });

                        // Prevent fullscreen on local video
                        localCameraVideo.controls = false;
                        localCameraVideo.addEventListener('webkitbeginfullscreen', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        }, true);
                        localCameraVideo.addEventListener('webkitendfullscreen', (e) => {
                            e.preventDefault();
                        }, true);

                        // Auto-resume if local video pauses unexpectedly
                        localCameraVideo.addEventListener('pause', () => {
                            console.log('‚è∏Ô∏è Local video paused - attempting to resume');
                            setTimeout(() => {
                                if (localCameraVideo.paused && localCameraVideo.srcObject) {
                                    localCameraVideo.play().catch(err => {
                                        console.log('‚ö†Ô∏è Could not resume local video:', err);
                                    });
                                }
                            }, 100);
                        });
                    } catch (playError) {
                        console.error('‚ùå Video play error:', playError);
                    }

                    // Update dropdown to show actual device being used
                    const videoTrack = localCameraStream.getVideoTracks()[0];
                    if (videoTrack) {
                        const settings = videoTrack.getSettings();
                        console.log('Camera settings:', settings);
                        if (settings.deviceId) {
                            cameraSelector.value = settings.deviceId;
                            selectedCameraDeviceId = settings.deviceId;
                        }
                    }

                    // Listen for video metadata loaded
                    localCameraVideo.addEventListener('loadedmetadata', function() {
                        console.log('üìä Video metadata loaded:', {
                            width: localCameraVideo.videoWidth,
                            height: localCameraVideo.videoHeight
                        });
                    });

                    // Listen for video data
                    localCameraVideo.addEventListener('loadeddata', function() {
                        console.log('üì¶ Video data loaded');
                    });

                    document.getElementById('status').textContent = 'Camera active';
                    document.getElementById('status').className = 'status connected';

                    // Add or replace video tracks in all peer connections
                    Object.keys(peerConnections).forEach(async (peerId) => {
                        const pc = peerConnections[peerId];
                        if (pc && pc.connectionState === 'connected') {
                            console.log('üîÑ Updating camera track for peer:', peerId);

                            // Find existing video sender
                            const senders = pc.getSenders();
                            const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');

                            const newVideoTrack = localCameraStream.getVideoTracks()[0];

                            if (videoSender) {
                                // Replace existing video track
                                try {
                                    await videoSender.replaceTrack(newVideoTrack);
                                    console.log('‚úÖ Replaced video track for peer:', peerId);
                                } catch (err) {
                                    console.error('‚ùå Failed to replace track for peer:', peerId, err);
                                }
                            } else {
                                // No existing video track, add new one
                                pc.addTrack(newVideoTrack, localCameraStream);
                                console.log('‚ûï Added new video track for peer:', peerId);

                                // Renegotiate when adding new track
                                try {
                                    const offer = await pc.createOffer();
                                    await pc.setLocalDescription(offer);
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: peerId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent renegotiation offer to peer:', peerId);
                                } catch (err) {
                                    console.error('‚ùå Renegotiation failed for peer:', peerId, err);
                                }
                            }
                        }
                    });

                    // Refresh camera list with proper labels
                    await populateCameraDevices();

                } catch (error) {
                    console.error('Camera access error:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);

                    let errorMsg = 'Camera error: ' + error.name;
                    if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        errorMsg = 'Camera not found - check if it\'s connected';
                    } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMsg = 'Camera permission denied - check browser settings';
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        errorMsg = 'Camera in use by another app';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMsg = 'Camera doesn\'t support requested settings';
                    }

                    document.getElementById('status').textContent = errorMsg;
                    document.getElementById('status').className = 'status disconnected';
                    alert(errorMsg + '\n\nDetails: ' + error.message);
                    throw error;
                }
            }

            async function switchCamera() {
                console.log('üîÑ Switching camera...');

                if (!isCameraEnabled) {
                    console.log('‚ö†Ô∏è Camera not enabled, cannot switch');
                    return;
                }

                try {
                    // Get list of video devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');

                    if (videoDevices.length < 2) {
                        console.log('‚ö†Ô∏è Only one camera available, cannot switch');
                        return;
                    }

                    // Find current camera index
                    const currentDeviceId = selectedCameraDeviceId;
                    const currentIndex = videoDevices.findIndex(device => device.deviceId === currentDeviceId);

                    // Get next camera (wrap around to 0 if at end)
                    const nextIndex = (currentIndex + 1) % videoDevices.length;
                    const nextDevice = videoDevices[nextIndex];

                    console.log('üìπ Switching from camera', currentIndex, 'to camera', nextIndex);
                    console.log('   From:', videoDevices[currentIndex]?.label || 'Unknown');
                    console.log('   To:', nextDevice.label || 'Unknown');

                    // Update selected device
                    selectedCameraDeviceId = nextDevice.deviceId;

                    // Save to localStorage
                    try {
                        localStorage.setItem('selectedCameraDeviceId', nextDevice.deviceId);
                        console.log('‚úÖ Saved camera preference to localStorage');
                    } catch (error) {
                        console.warn('Could not save camera preference:', error);
                    }

                    // Update dropdown
                    const cameraSelector = document.getElementById('cameraSelector');
                    if (cameraSelector) {
                        cameraSelector.value = nextDevice.deviceId;
                    }

                    // Stop current stream
                    if (localCameraStream) {
                        localCameraStream.getTracks().forEach(track => {
                            console.log('   Stopping track:', track.label);
                            track.stop();
                        });
                    }

                    // Start new camera
                    await startCamera();

                    console.log('‚úÖ Camera switched successfully');
                } catch (error) {
                    console.error('‚ùå Error switching camera:', error);
                    document.getElementById('status').textContent = 'Error switching camera: ' + error.message;
                    document.getElementById('status').className = 'status disconnected';
                }
            }

            async function toggleCamera() {
                const button = document.getElementById('cameraToggleButton');
                const cameraSwitchButton = document.getElementById('cameraSwitchButton');
                const icon = document.getElementById('cameraIcon');
                const label = document.getElementById('cameraLabel');
                const localCameraSection = document.getElementById('localCameraSection');
                const localCameraVideo = document.getElementById('localCameraVideo');

                if (!isCameraEnabled) {
                    console.log('Enabling camera...');
                    try {
                        await startCamera();

                        button.classList.add('active');
                        label.textContent = 'Camera On';
                        isCameraEnabled = true;

                        // Enable camera switch button
                        if (cameraSwitchButton) {
                            cameraSwitchButton.disabled = false;
                            cameraSwitchButton.style.background = '#007bff';
                        }

                        console.log('Camera enabled successfully');
                    } catch (error) {
                        console.error('Failed to enable camera:', error);
                        isCameraEnabled = false;
                    }
                } else {
                    console.log('Disabling camera...');
                    if (localCameraStream) {
                        localCameraStream.getTracks().forEach(track => {
                            console.log('Stopping track:', track.label);
                            track.stop();
                        });
                        localCameraStream = null;
                    }

                    localCameraVideo.srcObject = null;
                    localCameraSection.style.display = 'none';

                    button.classList.remove('active');
                    label.textContent = 'Enable Camera';

                    isCameraEnabled = false;

                    // Disable camera switch button
                    if (cameraSwitchButton) {
                        cameraSwitchButton.disabled = true;
                        cameraSwitchButton.style.background = '#666';
                    }

                    document.getElementById('status').textContent = 'Camera disabled';
                    document.getElementById('status').className = 'status disconnected';

                    console.log('Camera disabled');
                }
            }

            async function toggleMic() {
                const button = document.getElementById('micToggleButton');
                const icon = document.getElementById('micIcon');
                const label = document.getElementById('micLabel');

                if (!isMicEnabled) {
                    console.log('Enabling microphone...');
                    try {
                        localMicStream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            }
                        });

                        console.log('‚úÖ Microphone access granted!');
                        console.log('Audio tracks:', localMicStream.getAudioTracks().map(t => ({
                            id: t.id,
                            label: t.label,
                            enabled: t.enabled,
                            readyState: t.readyState
                        })));

                        button.classList.add('active');
                        label.textContent = 'Mic On';
                        isMicEnabled = true;

                        document.getElementById('status').textContent = 'Microphone enabled';
                        document.getElementById('status').className = 'status connected';

                        // Add audio tracks to all peer connections
                        Object.keys(peerConnections).forEach(peerId => {
                            const pc = peerConnections[peerId];
                            if (pc && pc.connectionState === 'connected') {
                                console.log('üì§ Adding audio track to peer:', peerId);
                                localMicStream.getAudioTracks().forEach(track => {
                                    pc.addTrack(track, localMicStream);
                                });

                                // Renegotiate
                                pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                    .then(() => {
                                        socket.emit(voiceOfferSocketEvent, {
                                            offer: pc.localDescription,
                                            to: peerId,
                                            cameraName: myCameraName
                                        });
                                    });
                            }
                        });

                        console.log('Microphone enabled successfully');
                    } catch (error) {
                        console.error('‚ùå Microphone access error:', error);

                        let errorMsg = 'Microphone error: ' + error.name;
                        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                            errorMsg = 'Microphone not found';
                        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                            errorMsg = 'Microphone permission denied - check browser settings';
                        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                            errorMsg = 'Microphone in use by another app';
                        }

                        document.getElementById('status').textContent = errorMsg;
                        document.getElementById('status').className = 'status disconnected';
                        alert(errorMsg + '\n\nDetails: ' + error.message);
                        isMicEnabled = false;
                    }
                } else {
                    console.log('Disabling microphone...');
                    if (localMicStream) {
                        localMicStream.getTracks().forEach(track => {
                            console.log('Stopping audio track:', track.label);
                            track.stop();
                        });
                        localMicStream = null;
                    }

                    button.classList.remove('active');
                    label.textContent = 'Enable Mic';
                    isMicEnabled = false;

                    document.getElementById('status').textContent = 'Microphone disabled';
                    document.getElementById('status').className = 'status disconnected';

                    console.log('Microphone disabled');
                }
            }

            function showPeerNotification(message, isJoin) {
                // Create or reuse notification element
                let notif = document.getElementById('peerNotification');
                if (!notif) {
                    notif = document.createElement('div');
                    notif.id = 'peerNotification';
                    notif.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        padding: 15px 30px;
                        border-radius: 10px;
                        font-size: 20px;
                        font-weight: bold;
                        z-index: 10000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        transition: opacity 0.3s;
                    `;
                    document.body.appendChild(notif);
                }

                notif.textContent = message;
                notif.style.backgroundColor = isJoin ? '#28a745' : '#dc3545';
                notif.style.color = 'white';
                notif.style.opacity = '1';

                // Flash animation
                notif.style.animation = 'none';
                notif.offsetHeight; // Trigger reflow
                notif.style.animation = 'pulse 0.5s ease-in-out 3';

                // Hide after 4 seconds
                clearTimeout(notif.hideTimeout);
                notif.hideTimeout = setTimeout(() => {
                    notif.style.opacity = '0';
                }, 4000);
            }

            function updatePeerCount() {
                const count = Object.keys(peerConnections).length;
                const peerCountEl = document.getElementById('peerCount');

                // Make peer count more prominent
                peerCountEl.textContent = 'üë• PEERS: ' + count;
                peerCountEl.style.fontSize = '18px';
                peerCountEl.style.fontWeight = 'bold';
                peerCountEl.style.padding = '5px 10px';
                peerCountEl.style.backgroundColor = count > 0 ? '#28a745' : '#6c757d';
                peerCountEl.style.color = 'white';
                peerCountEl.style.borderRadius = '5px';
                peerCountEl.style.display = 'inline-block';

                console.log('>>> updatePeerCount() called - count:', count, 'lastPeerCount:', lastPeerCount);

                // Show notification if peer count changed
                if (count > lastPeerCount) {
                    console.log('üö® PEER JOINED');
                    showPeerNotification('üü¢ Someone joined! Peers: ' + count, true);
                } else if (count < lastPeerCount) {
                    console.log('üö® PEER LEFT');
                    showPeerNotification('üî¥ Someone left. Peers: ' + count, false);
                }
                lastPeerCount = count;

                // Diagnostic: log peer connection states on Safari
                console.log('üìä Peer connections:', count);
                Object.keys(peerConnections).forEach(peerId => {
                    const pc = peerConnections[peerId];
                    const receivers = pc.getReceivers();
                    const videoReceivers = receivers.filter(r => r.track && r.track.kind === 'video');
                    const audioReceivers = receivers.filter(r => r.track && r.track.kind === 'audio');
                    console.log(`  Peer ${peerId.substring(0, 8)}:`,
                        'connection:', pc.connectionState,
                        'ice:', pc.iceConnectionState,
                        'video tracks:', videoReceivers.length,
                        'audio tracks:', audioReceivers.length);

                    // Log track states
                    videoReceivers.forEach((r, i) => {
                        console.log(`    Video ${i}:`, 'readyState:', r.track.readyState, 'muted:', r.track.muted);
                    });
                });
            }

            function updateEmptyState() {
                const remoteCameraGrid = document.getElementById('remoteCameraGrid');
                const emptyState = document.getElementById('emptyState');
                const hasRemoteCameras = remoteCameraGrid.children.length > 0;
                emptyState.style.display = hasRemoteCameras ? 'none' : 'block';
            }

            // Monitor if video element is actually rendering frames
            function monitorVideoRendering(videoElement, peerId, videoWrapper) {
                let noVideoCount = 0;
                const checkInterval = 3000; // Check every 3 seconds

                const renderMonitor = setInterval(() => {
                    // Check if video has dimensions (indicates it's loaded)
                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        // Video has dimensions, reset counter
                        noVideoCount = 0;

                        // Update badge to show resolution
                        const badge = videoWrapper.querySelector('.badge');
                        if (badge && badge.textContent === 'LIVE') {
                            // Optionally show resolution
                            // badge.textContent = `${videoElement.videoWidth}x${videoElement.videoHeight}`;
                        }
                    } else {
                        // Video element exists but has no dimensions (black screen)
                        noVideoCount++;

                        if (noVideoCount >= 3) { // 9 seconds of black screen
                            console.error(`‚¨õ Black screen detected for peer ${peerId}! (${noVideoCount} consecutive)`);
                            console.log('Video element state:', {
                                readyState: videoElement.readyState,
                                networkState: videoElement.networkState,
                                paused: videoElement.paused,
                                videoWidth: videoElement.videoWidth,
                                videoHeight: videoElement.videoHeight,
                                srcObject: !!videoElement.srcObject
                            });

                            // Update badge to show issue
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'NO VIDEO';
                                badge.style.background = '#000';
                                badge.style.color = '#fff';
                            }

                            // Auto-purge orphaned peer after 30 seconds (10 consecutive black screen detections)
                            if (noVideoCount >= 10) {
                                console.warn(`üóëÔ∏è Auto-purging orphaned peer ${peerId} after ${noVideoCount * 3} seconds of black screen`);
                                clearInterval(renderMonitor);
                                cleanupPeerConnection(peerId);
                                return;
                            }
                        }
                    }
                }, checkInterval);

                // Store monitor so we can clean it up
                videoElement._renderMonitor = renderMonitor;
            }

            // Monitor connection quality and detect frozen streams
            function monitorConnectionQuality(pc, peerId) {
                const checkInterval = 5000; // Check every 5 seconds
                let lastBytesReceived = 0;
                let noDataCount = 0;

                const qualityMonitor = setInterval(async () => {
                    if (!pc || pc.connectionState === 'closed') {
                        clearInterval(qualityMonitor);
                        return;
                    }

                    try {
                        const stats = await pc.getStats();
                        let currentBytesReceived = 0;
                        let packetsLost = 0;
                        let packetsReceived = 0;

                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                currentBytesReceived = report.bytesReceived || 0;
                                packetsLost = report.packetsLost || 0;
                                packetsReceived = report.packetsReceived || 0;
                            }
                        });

                        // Check if we're receiving data
                        if (currentBytesReceived === lastBytesReceived && currentBytesReceived > 0) {
                            noDataCount++;
                            console.warn(`‚ö†Ô∏è No new data from peer ${peerId} for ${noDataCount * checkInterval / 1000} seconds`);

                            // If frozen for 15 seconds, attempt ICE restart
                            if (noDataCount >= 3) {
                                console.error(`‚ùå Stream from peer ${peerId} appears frozen! Attempting ICE restart...`);
                                attemptIceRestart(pc, peerId);
                                noDataCount = 0; // Reset counter after restart attempt
                            }
                        } else {
                            noDataCount = 0;
                        }

                        // Log packet loss if significant
                        if (packetsReceived > 0) {
                            const lossRate = (packetsLost / (packetsLost + packetsReceived)) * 100;
                            if (lossRate > 5) {
                                console.warn(`üìä Peer ${peerId} packet loss: ${lossRate.toFixed(1)}%`);
                            }
                        }

                        lastBytesReceived = currentBytesReceived;
                    } catch (err) {
                        console.error('Error checking connection quality:', err);
                    }
                }, checkInterval);

                // Store the interval so we can clear it later
                pc._qualityMonitor = qualityMonitor;
            }

            // Attempt ICE restart to recover frozen connection
            async function attemptIceRestart(pc, peerId) {
                if (!pc || pc.connectionState === 'closed') return;

                console.log('üîÑ Attempting ICE restart for peer:', peerId);

                try {
                    // Create new offer with iceRestart option
                    const offer = await pc.createOffer({ iceRestart: true });
                    await pc.setLocalDescription(offer);

                    socket.emit(voiceOfferSocketEvent, {
                        offer: pc.localDescription,
                        to: peerId,
                        cameraName: myCameraName
                    });

                    console.log('‚úÖ ICE restart offer sent to peer:', peerId);
                } catch (err) {
                    console.error('‚ùå ICE restart failed for peer:', peerId, err);
                }
            }

            // Refresh a single peer connection (triggered by individual refresh button)
            async function refreshSinglePeer(peerId) {
                console.log('üîÑ Refreshing single peer connection:', peerId);

                const pc = peerConnections[peerId];
                if (!pc) {
                    console.warn('‚ö†Ô∏è No peer connection found for:', peerId);
                    return;
                }

                // Update UI to show refreshing
                const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                if (videoWrapper) {
                    const badge = videoWrapper.querySelector('.badge');
                    if (badge) {
                        badge.textContent = 'REFRESHING';
                        badge.style.background = '#17a2b8';
                    }
                }

                // First try ICE restart
                try {
                    await attemptIceRestart(pc, peerId);
                    console.log('‚úÖ ICE restart initiated for:', peerId);
                } catch (err) {
                    console.error('‚ùå ICE restart failed, attempting full reconnection:', err);

                    // Full reconnection: close and recreate
                    cleanupPeerConnection(peerId);

                    // Request peer to reconnect
                    socket.emit(endpoint + 'cameracamera' + 'requestroster', {
                        userId: socket.id
                    });
                }
            }

            // Immediate diagnostic update for a peer (called when button clicked)
            async function updatePeerDiagnosticsNow(peerId) {
                const diagDiv = document.getElementById('diagnostics_' + peerId);
                const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                const videoElement = videoWrapper ? videoWrapper.querySelector('video') : null;
                const pc = peerConnections[peerId];

                if (!diagDiv) {
                    console.error('No diagnostics div for peer:', peerId);
                    return;
                }

                let html = '';
                html += `<div><span class="label">Peer:</span> <span class="value">${peerId.substring(0, 12)}...</span></div>`;

                if (!pc) {
                    html += `<div><span class="error">NO PEER CONNECTION</span></div>`;
                    html += `<div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;
                    html += `<div><span class="warn">Try clicking üîÑ to refresh</span></div>`;
                    diagDiv.innerHTML = html;
                    return;
                }

                if (!videoElement) {
                    html += `<div><span class="error">NO VIDEO ELEMENT</span></div>`;
                    html += `<div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;
                    diagDiv.innerHTML = html;
                    return;
                }

                // Video dimensions
                const hasVideo = videoElement.videoWidth > 0 && videoElement.videoHeight > 0;
                html += `<div><span class="label">Resolution:</span> <span class="${hasVideo ? 'value' : 'error'}">${hasVideo ? videoElement.videoWidth + 'x' + videoElement.videoHeight : 'NO VIDEO (0x0)'}</span></div>`;

                // Video state
                const videoState = videoElement.paused ? 'PAUSED' : (videoElement.ended ? 'ENDED' : 'PLAYING');
                html += `<div><span class="label">Video:</span> <span class="${videoElement.paused ? 'warn' : 'value'}">${videoState}</span></div>`;
                html += `<div><span class="label">Ready:</span> <span class="value">${videoElement.readyState}/4</span></div>`;

                // Track state
                const srcObj = videoElement.srcObject;
                if (srcObj) {
                    try {
                        const tracks = srcObj.getVideoTracks();
                        if (tracks.length > 0) {
                            const track = tracks[0];
                            const trackInfo = `${track.readyState}${track.muted ? ' MUTED' : ''}${!track.enabled ? ' DISABLED' : ''}`;
                            const trackBad = track.readyState === 'ended' || track.muted || !track.enabled;
                            html += `<div><span class="label">Track:</span> <span class="${trackBad ? 'error' : 'value'}">${trackInfo}</span></div>`;
                        } else {
                            html += `<div><span class="label">Track:</span> <span class="error">NO TRACKS</span></div>`;
                        }
                    } catch (e) {
                        html += `<div><span class="label">Track:</span> <span class="error">${e.message}</span></div>`;
                    }
                } else {
                    html += `<div><span class="label">Source:</span> <span class="error">NO SOURCE</span></div>`;
                }

                // Connection state
                const connState = pc.connectionState || 'unknown';
                const iceState = pc.iceConnectionState || 'unknown';
                const connBad = connState === 'failed' || connState === 'closed' || connState === 'disconnected';
                const iceBad = iceState === 'failed' || iceState === 'closed' || iceState === 'disconnected';
                html += `<div><span class="label">Conn:</span> <span class="${connBad ? 'error' : 'value'}">${connState}</span></div>`;
                html += `<div><span class="label">ICE:</span> <span class="${iceBad ? 'error' : 'value'}">${iceState}</span></div>`;

                if (connBad || iceBad) {
                    html += `<div><span class="warn">‚ö†Ô∏è Connection lost</span></div>`;
                } else {
                    // Get stats only if connection OK
                    try {
                        const stats = await pc.getStats();
                        let bytesReceived = 0, packetsLost = 0, packetsReceived = 0;
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                bytesReceived = report.bytesReceived || 0;
                                packetsLost = report.packetsLost || 0;
                                packetsReceived = report.packetsReceived || 0;
                            }
                        });
                        const kb = (bytesReceived / 1000).toFixed(1);
                        const lossRate = packetsReceived > 0 ? ((packetsLost / (packetsLost + packetsReceived)) * 100).toFixed(1) : 0;
                        html += `<div><span class="label">Data:</span> <span class="value">${kb} KB</span></div>`;
                        html += `<div><span class="label">Loss:</span> <span class="${lossRate > 5 ? 'error' : 'value'}">${lossRate}%</span></div>`;
                    } catch (e) {
                        html += `<div><span class="error">Stats: ${e.message}</span></div>`;
                    }
                }

                html += `<div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;
                diagDiv.innerHTML = html;
            }

            // Start diagnostic updates for a peer video
            function startPeerDiagnostics(peerId, videoElement) {
                // Function to update diagnostics - wrapped in try/catch to never fail silently
                async function updateDiagnostics() {
                    try {
                        const diagDiv = document.getElementById('diagnostics_' + peerId);

                        if (!diagDiv) {
                            return false; // Element gone, stop interval
                        }

                        // Only update if visible
                        if (!diagDiv.classList.contains('visible')) {
                            return true; // Keep interval running
                        }

                        const pc = peerConnections[peerId];
                        let html = '';

                        // Always show peer ID first
                        html += `<div><span class="label">Peer:</span> <span class="value">${peerId.substring(0, 12)}...</span></div>`;

                        // Check if peer connection exists
                        if (!pc) {
                            html += `<div><span class="error">NO PEER CONNECTION</span></div>`;
                            html += `<div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;
                            html += `<div><span class="warn">Try clicking üîÑ to refresh</span></div>`;
                            diagDiv.innerHTML = html;
                            return true; // Keep running in case connection comes back
                        }

                        // Video dimensions
                        const hasVideo = videoElement && videoElement.videoWidth > 0 && videoElement.videoHeight > 0;
                        if (hasVideo) {
                            html += `<div><span class="label">Resolution:</span> <span class="value">${videoElement.videoWidth}x${videoElement.videoHeight}</span></div>`;
                        } else {
                            html += `<div><span class="label">Resolution:</span> <span class="error">NO VIDEO (0x0)</span></div>`;
                        }

                        // Video element state
                        if (videoElement) {
                            const videoState = videoElement.paused ? 'PAUSED' : (videoElement.ended ? 'ENDED' : 'PLAYING');
                            const videoStateClass = videoElement.paused ? 'warn' : 'value';
                            html += `<div><span class="label">Video State:</span> <span class="${videoStateClass}">${videoState}</span></div>`;
                            html += `<div><span class="label">Ready State:</span> <span class="value">${videoElement.readyState}/4</span></div>`;

                            // Source object
                            const srcObj = videoElement.srcObject;
                            if (srcObj) {
                                try {
                                    const tracks = srcObj.getVideoTracks();
                                    if (tracks.length > 0) {
                                        const track = tracks[0];
                                        const trackState = track.readyState; // 'live' or 'ended'
                                        const trackMuted = track.muted;
                                        const trackEnabled = track.enabled;
                                        const trackClass = (trackState === 'ended' || trackMuted || !trackEnabled) ? 'error' : 'value';
                                        html += `<div><span class="label">Track:</span> <span class="${trackClass}">${trackState}${trackMuted ? ' MUTED' : ''}${!trackEnabled ? ' DISABLED' : ''}</span></div>`;
                                    } else {
                                        html += `<div><span class="label">Track:</span> <span class="error">NO VIDEO TRACKS</span></div>`;
                                    }
                                } catch (trackErr) {
                                    html += `<div><span class="label">Track:</span> <span class="error">ERROR: ${trackErr.message}</span></div>`;
                                }
                            } else {
                                html += `<div><span class="label">Source:</span> <span class="error">NO SOURCE</span></div>`;
                            }
                        } else {
                            html += `<div><span class="error">NO VIDEO ELEMENT</span></div>`;
                        }

                        // Connection states
                        const connState = pc.connectionState || 'unknown';
                        const iceState = pc.iceConnectionState || 'unknown';
                        const connClass = (connState === 'connected') ? 'value' : (connState === 'failed' || connState === 'closed') ? 'error' : 'warn';
                        const iceClass = (iceState === 'connected' || iceState === 'completed') ? 'value' : (iceState === 'failed' || iceState === 'closed' || iceState === 'disconnected') ? 'error' : 'warn';
                        html += `<div><span class="label">Connection:</span> <span class="${connClass}">${connState}</span></div>`;
                        html += `<div><span class="label">ICE:</span> <span class="${iceClass}">${iceState}</span></div>`;

                        // If connection is bad, show a hint and skip stats
                        const connectionBad = (connState === 'failed' || connState === 'closed' || connState === 'disconnected' ||
                            iceState === 'failed' || iceState === 'closed' || iceState === 'disconnected');

                        if (connectionBad) {
                            html += `<div><span class="warn">‚ö†Ô∏è Connection lost - try üîÑ refresh</span></div>`;
                        } else {
                            // Only try to get WebRTC stats if connection looks OK
                            try {
                                const stats = await pc.getStats();
                                let bytesReceived = 0;
                                let packetsLost = 0;
                                let packetsReceived = 0;
                                let framesReceived = 0;
                                let framesDecoded = 0;
                                let framesDropped = 0;
                                let jitter = 0;
                                let timestamp = 0;

                                stats.forEach(report => {
                                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                        bytesReceived = report.bytesReceived || 0;
                                        packetsLost = report.packetsLost || 0;
                                        packetsReceived = report.packetsReceived || 0;
                                        framesReceived = report.framesReceived || 0;
                                        framesDecoded = report.framesDecoded || 0;
                                        framesDropped = report.framesDropped || 0;
                                        jitter = report.jitter || 0;
                                        timestamp = report.timestamp || 0;
                                    }
                                });

                                // Calculate data rate (compare with last update)
                                const lastBytes = videoElement._lastBytesReceived || 0;
                                const lastTime = videoElement._lastStatsTime || timestamp;
                                const timeDiff = (timestamp - lastTime) / 1000; // seconds
                                const bytesDiff = bytesReceived - lastBytes;
                                const dataRate = timeDiff > 0 ? (bytesDiff * 8 / timeDiff / 1000).toFixed(1) : 0; // kbps

                                videoElement._lastBytesReceived = bytesReceived;
                                videoElement._lastStatsTime = timestamp;

                                // Format bytes
                                const bytesFormatted = bytesReceived > 1000000 ?
                                    (bytesReceived / 1000000).toFixed(2) + ' MB' :
                                    (bytesReceived / 1000).toFixed(1) + ' KB';

                                html += `<div><span class="label">Data:</span> <span class="value">${bytesFormatted} (${dataRate} kbps)</span></div>`;

                                // Packet loss
                                const lossRate = packetsReceived > 0 ?
                                    ((packetsLost / (packetsLost + packetsReceived)) * 100).toFixed(1) : 0;
                                const lossClass = lossRate > 5 ? 'error' : lossRate > 1 ? 'warn' : 'value';
                                html += `<div><span class="label">Packet Loss:</span> <span class="${lossClass}">${lossRate}% (${packetsLost}/${packetsReceived + packetsLost})</span></div>`;

                                // Frames
                                const droppedClass = framesDropped > 0 ? 'warn' : 'value';
                                html += `<div><span class="label">Frames:</span> <span class="value">recv: ${framesReceived} dec: ${framesDecoded}</span> <span class="${droppedClass}">drop: ${framesDropped}</span></div>`;

                                // Jitter
                                html += `<div><span class="label">Jitter:</span> <span class="value">${(jitter * 1000).toFixed(1)} ms</span></div>`;

                                // Data rate warning
                                if (dataRate == 0 && bytesReceived > 0) {
                                    html += `<div><span class="error">‚ö†Ô∏è NO DATA FLOW - stream may be frozen!</span></div>`;
                                }

                            } catch (statsErr) {
                                html += `<div><span class="error">Stats: ${statsErr.message}</span></div>`;
                            }
                        }

                        // Timestamp - always show this last
                        html += `<div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;

                        diagDiv.innerHTML = html;
                        return true; // Keep interval running

                    } catch (outerErr) {
                        // Catastrophic error - still try to show something
                        const diagDiv = document.getElementById('diagnostics_' + peerId);
                        if (diagDiv) {
                            diagDiv.innerHTML = `<div><span class="error">Diagnostic error: ${outerErr.message}</span></div><div><span class="label">Updated:</span> <span class="value">${new Date().toLocaleTimeString()}</span></div>`;
                        }
                        console.error('Diagnostics error for peer', peerId, outerErr);
                        return true; // Keep trying
                    }
                }

                // Set up interval for updates (every 1 second for more responsive diagnostics)
                const diagInterval = setInterval(async () => {
                    const shouldContinue = await updateDiagnostics();
                    if (!shouldContinue) {
                        clearInterval(diagInterval);
                    }
                }, 1000); // Update every 1 second

                // Store interval for cleanup
                videoElement._diagInterval = diagInterval;
            }

            // Clean up peer connection and all associated resources
            function cleanupPeerConnection(peerId) {
                console.log('üßπ Cleaning up peer connection:', peerId);

                const pc = peerConnections[peerId];
                if (pc) {
                    // Clean up quality monitor
                    if (pc._qualityMonitor) {
                        clearInterval(pc._qualityMonitor);
                    }

                    // Close the connection
                    pc.close();
                    delete peerConnections[peerId];
                }

                // Clean up camera name
                if (peerCameraNames[peerId]) {
                    console.log('üßπ Removing camera name for peer:', peerId, 'was:', peerCameraNames[peerId]);
                    delete peerCameraNames[peerId];
                }

                // Clean up video element and monitors
                const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                if (videoWrapper) {
                    const video = videoWrapper.querySelector('video');
                    if (video) {
                        if (video._renderMonitor) {
                            clearInterval(video._renderMonitor);
                        }
                        if (video._diagInterval) {
                            clearInterval(video._diagInterval);
                        }
                    }
                    videoWrapper.remove();
                }

                // Clean up audio element
                const audioElement = document.getElementById('remoteAudio_' + peerId);
                if (audioElement) {
                    audioElement.remove();
                }

                // Clean up data structures
                delete remoteCameraStreams[peerId];
                delete pendingIceCandidates[peerId];
                delete peerCameraNames[peerId];

                updatePeerCount();
                updateEmptyState();
                console.log('‚úÖ Cleanup complete for peer:', peerId);
            }

            // WebRTC functions
            function initializeSocketHandlers() {
                socket.on(endpoint + 'cameracamera' + 'voiceoffer', handleOffer);
                socket.on(endpoint + 'cameracamera' + 'voiceanswer', handleAnswer);
                socket.on(endpoint + 'cameracamera' + 'voiceicecandidate', handleIceCandidate);
                socket.on(endpoint + 'cameracamera' + 'disconnect', handlePeerDisconnect);
                socket.on(endpoint + 'cameracamera' + 'nameupdate', handleCameraNameUpdate);
                socket.on(endpoint + 'cameracamera' + 'reconnect', handlePeerReconnect);
                socket.on(endpoint + 'cameracamera' + 'requestroster', handleRosterRequest);
                socket.on(endpoint + 'cameracamera' + 'rosterresponse', handleRosterResponse);
            }

            function handleRosterResponse(data) {
                console.log('üì• Received roster response from:', data.from, 'name:', data.cameraName || '(none)');

                // Store camera name if provided
                if (data.cameraName) {
                    peerCameraNames[data.from] = data.cameraName;
                }

                // If we don't have a peer connection yet, create one
                if (!peerConnections[data.from]) {
                    console.log('üîó Creating peer connection to roster responder:', data.from);
                    const pc = createPeerConnection(data.from);

                    // Always create offer as the refreshing peer
                    // This ensures connection establishment works regardless of ID ordering
                    pc.createOffer().then(offer => pc.setLocalDescription(offer))
                        .then(() => {
                            socket.emit(voiceOfferSocketEvent, {
                                offer: pc.localDescription,
                                to: data.from,
                                cameraName: myCameraName
                            });
                            console.log('üì§ Sent offer to roster responder:', data.from);
                        })
                        .catch(err => {
                            console.error('‚ùå Error creating offer for roster responder:', err);
                        });
                } else {
                    console.log('‚ÑπÔ∏è Already connected to:', data.from);
                }
            }

            function handleRosterRequest(data) {
                console.log('üìã Peer requesting roster:', data.userId, '(my ID:', socket.id, ')');

                // Only respond if this is a different peer
                if (data.userId !== socket.id) {
                    console.log('üì¢ Announcing my presence to:', data.userId, 'with name:', myCameraName || '(none)');

                    // Send a roster response so the requester knows we exist
                    socket.emit(endpoint + 'cameracamera' + 'rosterresponse', {
                        to: data.userId,
                        cameraName: myCameraName || ''
                    });

                    // Directly create peer connection if we don't already have one
                    if (!peerConnections[data.userId]) {
                        console.log('Creating peer connection for roster requester:', data.userId);

                        const pc = createPeerConnection(data.userId);

                        // Use glare resolution to decide who creates offer
                        const shouldCreateOffer = socket.id < data.userId;
                        console.log('Glare resolution - should I create offer?', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                        if (shouldCreateOffer) {
                            // Create and send offer
                            pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                .then(() => {
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: data.userId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent offer to roster requester:', data.userId);
                                })
                                .catch(err => {
                                    console.error('‚ùå Error creating offer for roster requester:', err);
                                });
                        } else {
                            console.log('‚è∏Ô∏è Created peer connection, waiting for offer from:', data.userId);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è Already have peer connection for:', data.userId);
                    }

                    // Also send our camera name if we have one
                    if (myCameraName) {
                        socket.emit(cameraNameUpdateSocketEvent, {
                            cameraName: myCameraName
                        });
                    }
                } else {
                    console.log('‚ÑπÔ∏è Ignoring roster request from myself');
                }
            }

            function handlePeerReconnect(data) {
                console.log('üîî Peer requesting reconnection:', data.userId);

                // Only respond if this is a different peer
                if (data.userId !== socket.id) {
                    // Glare resolution: only the peer with the lower ID creates the offer
                    // This prevents both peers from sending offers simultaneously
                    const shouldCreateOffer = socket.id < data.userId;

                    console.log('Should create offer:', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                    if (shouldCreateOffer) {
                        console.log('Creating new peer connection for reconnecting peer:', data.userId);

                        // Create peer connection (will add any enabled media tracks)
                        const pc = createPeerConnection(data.userId);

                        // Send offer to the reconnecting peer
                        pc.createOffer().then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                socket.emit(voiceOfferSocketEvent, {
                                    offer: pc.localDescription,
                                    to: data.userId,
                                    cameraName: myCameraName
                                });
                                console.log('üì§ Sent offer to reconnecting peer:', data.userId);
                            })
                            .catch(err => {
                                console.error('‚ùå Error creating offer for reconnecting peer:', err);
                            });
                    } else {
                        console.log('‚è∏Ô∏è Waiting for offer from peer:', data.userId, '(they have lower ID)');
                        // Still create the peer connection so we're ready to receive their offer
                        createPeerConnection(data.userId);
                    }
                }
            }

            function handleCameraNameUpdate(data) {
                console.log('üì• Received camera name update from:', data.userId, 'name:', data.cameraName || '(cleared)');

                // Ignore updates from ourselves
                if (data.userId === socket.id) {
                    console.log('‚è≠Ô∏è Ignoring our own camera name update');
                    return;
                }

                // Store the new name
                if (data.cameraName) {
                    peerCameraNames[data.userId] = data.cameraName;
                } else {
                    delete peerCameraNames[data.userId];
                }

                // Update the video label if it exists
                const videoWrapper = document.getElementById('remoteVideo_' + data.userId);
                if (videoWrapper) {
                    const label = videoWrapper.querySelector('.camera-label span:first-child');
                    if (label) {
                        const displayName = peerCameraNames[data.userId] || `Peer ${data.userId.substring(0, 8)}`;
                        label.textContent = `üìπ ${displayName}`;
                        console.log('‚úÖ Updated video label for', data.userId, 'to:', displayName);
                    }
                } else {
                    console.log('‚ö†Ô∏è No video element found for peer:', data.userId);

                    // IMPORTANT: If we received a name update but have no peer connection,
                    // it means the peer exists but we're not connected. Try to establish connection!
                    if (!peerConnections[data.userId]) {
                        console.log('üîó Attempting to establish connection with:', data.userId);

                        const pc = createPeerConnection(data.userId);

                        // Use glare resolution to decide who creates offer
                        const shouldCreateOffer = socket.id < data.userId;
                        console.log('Glare resolution:', shouldCreateOffer ? 'I create offer' : 'I wait for offer', '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                        if (shouldCreateOffer) {
                            // Create and send offer
                            pc.createOffer().then(offer => pc.setLocalDescription(offer))
                                .then(() => {
                                    socket.emit(voiceOfferSocketEvent, {
                                        offer: pc.localDescription,
                                        to: data.userId,
                                        cameraName: myCameraName
                                    });
                                    console.log('üì§ Sent offer to discovered peer:', data.userId);
                                })
                                .catch(err => {
                                    console.error('‚ùå Error creating offer for discovered peer:', err);
                                });
                        } else {
                            console.log('‚è∏Ô∏è Created peer connection, waiting for offer from discovered peer:', data.userId);
                            // Request the peer to send us an offer
                            socket.emit(endpoint + 'cameracamera' + 'reconnect', {
                                userId: socket.id
                            });
                        }
                    }
                }
            }

            function createPeerConnection(peerId) {
                if (peerConnections[peerId]) {
                    return peerConnections[peerId];
                }

                const pc = new RTCPeerConnection(iceServers);
                peerConnections[peerId] = pc;

                console.log('Creating peer connection for:', peerId);

                // Add local camera tracks if enabled
                if (localCameraStream) {
                    localCameraStream.getTracks().forEach(track => {
                        console.log('Adding camera track to peer:', peerId, 'kind:', track.kind);
                        pc.addTrack(track, localCameraStream);
                    });
                } else {
                    // No local camera - add a recvonly transceiver so we can still receive video
                    // This is needed for devices without cameras (like Mac Mini) to receive peer video
                    console.log('No local camera - adding recvonly video transceiver for peer:', peerId);
                    pc.addTransceiver('video', { direction: 'recvonly' });
                }

                // Add local microphone tracks if enabled
                if (localMicStream) {
                    localMicStream.getTracks().forEach(track => {
                        console.log('Adding mic track to peer:', peerId, 'kind:', track.kind);
                        pc.addTrack(track, localMicStream);
                    });
                }

                pc.onicecandidate = function(event) {
                    if (event.candidate) {
                        socket.emit(voiceIceCandidateSocketEvent, {
                            candidate: event.candidate,
                            to: peerId
                        });
                    }
                };

                pc.ontrack = function(event) {
                    console.log('üì• Received track from peer:', peerId, 'kind:', event.track.kind, 'readyState:', event.track.readyState, 'muted:', event.track.muted);
                    console.log('   Track ID:', event.track.id, 'Streams:', event.streams.length);

                    if (event.track.kind === 'video') {
                        const acceptCameraCheckbox = document.getElementById('acceptCameraCheckbox');
                        if (!acceptCameraCheckbox.checked) {
                            console.log('Video track rejected - camera checkbox not checked');
                            return;
                        }

                        const remoteCameraGrid = document.getElementById('remoteCameraGrid');
                        let videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        let isNewVideoElement = false;

                        if (!videoWrapper) {
                            isNewVideoElement = true;
                            videoWrapper = document.createElement('div');
                            videoWrapper.id = 'remoteVideo_' + peerId;
                            videoWrapper.className = 'camera-card';

                            const label = document.createElement('div');
                            label.className = 'camera-label';
                            const displayName = peerCameraNames[peerId] || `Peer ${peerId.substring(0, 8)}`;
                            label.innerHTML = `<span>üìπ ${displayName}</span><span class="badge">LIVE</span>`;

                            // Action buttons (refresh, diagnostics toggle)
                            const actions = document.createElement('div');
                            actions.className = 'peer-actions';

                            // Refresh button for this peer
                            const refreshBtn = document.createElement('button');
                            refreshBtn.className = 'peer-action-btn';
                            refreshBtn.innerHTML = 'üîÑ';
                            refreshBtn.title = 'Refresh this peer connection';
                            refreshBtn.onclick = (e) => {
                                e.stopPropagation();
                                refreshSinglePeer(peerId);
                            };

                            // Diagnostics toggle button
                            const diagBtn = document.createElement('button');
                            diagBtn.className = 'peer-action-btn';
                            diagBtn.innerHTML = 'üìä';
                            diagBtn.title = 'Toggle diagnostics';
                            diagBtn.onclick = (e) => {
                                e.stopPropagation();
                                const diag = videoWrapper.querySelector('.peer-diagnostics');
                                if (diag) {
                                    const wasHidden = !diag.classList.contains('visible');
                                    diag.classList.toggle('visible');
                                    diagBtn.classList.toggle('active');
                                    // Trigger immediate update when showing
                                    if (wasHidden && diag.classList.contains('visible')) {
                                        // Call updatePeerDiagnosticsNow directly
                                        updatePeerDiagnosticsNow(peerId);
                                    }
                                }
                            };

                            // Maximize button
                            const maxBtn = document.createElement('button');
                            maxBtn.className = 'peer-action-btn';
                            maxBtn.innerHTML = '‚õ∂';
                            maxBtn.title = 'Maximize video';
                            maxBtn.onclick = (e) => {
                                e.stopPropagation();
                                maximizeVideo('remoteVideoElement_' + peerId, displayName);
                            };

                            // Audio mute button for this peer (starts disabled until audio track received)
                            const audioBtn = document.createElement('button');
                            audioBtn.className = 'peer-action-btn';
                            audioBtn.id = 'audioBtn_' + peerId;
                            audioBtn.innerHTML = 'üîá';
                            audioBtn.title = 'No audio from this peer';
                            audioBtn.disabled = true;
                            audioBtn.onclick = (e) => {
                                e.stopPropagation();
                                togglePeerAudio(peerId);
                            };

                            actions.appendChild(refreshBtn);
                            actions.appendChild(diagBtn);
                            actions.appendChild(maxBtn);
                            actions.appendChild(audioBtn);

                            // Diagnostics overlay
                            const diagnostics = document.createElement('div');
                            diagnostics.className = 'peer-diagnostics';
                            diagnostics.id = 'diagnostics_' + peerId;
                            diagnostics.innerHTML = '<div><span class="label">Loading diagnostics...</span></div>';

                            const video = document.createElement('video');
                            video.id = 'remoteVideoElement_' + peerId;
                            video.autoplay = true;
                            video.playsinline = true;
                            video.muted = true; // Mute to help autoplay on mobile
                            video.setAttribute('webkit-playsinline', '');
                            video.setAttribute('disablePictureInPicture', '');
                            video.setAttribute('x5-playsinline', ''); // Android WeChat
                            video.setAttribute('x5-video-player-type', 'h5');
                            video.setAttribute('x-webkit-airplay', 'allow');

                            // Prevent default video controls and fullscreen
                            video.controls = false;
                            video.addEventListener('webkitbeginfullscreen', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }, true);
                            video.addEventListener('webkitendfullscreen', (e) => {
                                e.preventDefault();
                            }, true);

                            videoWrapper.appendChild(label);
                            videoWrapper.appendChild(actions);
                            videoWrapper.appendChild(video);
                            videoWrapper.appendChild(diagnostics);
                            remoteCameraGrid.appendChild(videoWrapper);

                            // Start diagnostic updates for this peer
                            startPeerDiagnostics(peerId, video);

                            // Auto-resume if video pauses unexpectedly
                            video.addEventListener('pause', () => {
                                console.log('‚è∏Ô∏è Video paused unexpectedly for peer:', peerId, '- attempting to resume');
                                setTimeout(() => {
                                    if (video.paused && video.srcObject) {
                                        safePlayVideo(video).catch(err => {
                                            console.log('‚ö†Ô∏è Could not resume video for peer:', peerId, err);
                                        });
                                    }
                                }, 100);
                            });

                            console.log('‚úÖ Created video element for peer:', peerId);
                        }

                        // Get the video element (whether new or existing)
                        const video = videoWrapper.querySelector('video');

                        // Update or set the stream (handles both new tracks and renegotiation)
                        // Handle case where track arrives without an associated stream (common with aiortc)
                        let remoteStream = event.streams[0];
                        if (!remoteStream) {
                            console.warn('‚ö†Ô∏è No stream provided with track from peer:', peerId, '- creating synthetic stream');
                            remoteStream = new MediaStream([event.track]);
                        }

                        if (video.srcObject !== remoteStream) {
                            console.log('üîÑ Updating video stream for peer:', peerId);

                            // Clean up old monitors if exists
                            if (video._renderMonitor) {
                                clearInterval(video._renderMonitor);
                            }
                            if (video._diagInterval) {
                                clearInterval(video._diagInterval);
                            }

                            video.srcObject = remoteStream;
                            remoteCameraStreams[peerId] = remoteStream;

                            // Force play safely without triggering fullscreen
                            safePlayVideo(video).catch(err => {
                                console.log('‚ö†Ô∏è Autoplay prevented for peer:', peerId, err);
                            });
                        } else {
                            console.log('‚ÑπÔ∏è Same stream already assigned for peer:', peerId);
                        }

                        // Only monitor video rendering if this is a new element
                        if (isNewVideoElement) {
                            monitorVideoRendering(video, peerId, videoWrapper);
                        }

                        // Monitor video track state
                        event.track.onended = function() {
                            console.warn('‚ö†Ô∏è Video track ended for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'OFFLINE';
                                badge.style.background = '#dc3545';
                            }
                        };

                        event.track.onmute = function() {
                            console.warn('üîá Video track muted for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'MUTED';
                                badge.style.background = '#ffc107';
                            }

                            // iOS Safari aggressively mutes video tracks - try to recover
                            // by forcing a video play() which can help unmute
                            const video = videoWrapper.querySelector('video');
                            if (video && video.srcObject) {
                                console.log('üîÑ Attempting to recover muted track for peer:', peerId);
                                safePlayVideo(video).catch(err => {
                                    console.log('‚ö†Ô∏è Could not restart video:', err.message);
                                });
                            }
                        };

                        event.track.onunmute = function() {
                            console.log('üîä Video track unmuted for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'LIVE';
                                badge.style.background = '#28a745';
                            }
                        };

                        // Monitor stream state
                        event.streams[0].onactive = function() {
                            console.log('‚úÖ Stream became active for peer:', peerId);
                        };

                        event.streams[0].oninactive = function() {
                            console.warn('‚ö†Ô∏è Stream became inactive for peer:', peerId);
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'INACTIVE';
                                badge.style.background = '#6c757d';
                            }
                        };

                        updateEmptyState();
                    } else if (event.track.kind === 'audio') {
                        console.log('üé§ Received audio track from peer:', peerId);

                        // Create or get audio element for this peer
                        let audioElement = document.getElementById('remoteAudio_' + peerId);
                        if (!audioElement) {
                            audioElement = document.createElement('audio');
                            audioElement.id = 'remoteAudio_' + peerId;
                            audioElement.autoplay = true;
                            // Use per-peer mute state if set, otherwise fall back to global state
                            const peerMuteState = peerAudioMuted[peerId] !== undefined ? peerAudioMuted[peerId] : isRemoteAudioMuted;
                            peerAudioMuted[peerId] = peerMuteState;
                            audioElement.muted = peerMuteState;
                            audioElement.volume = 1.0;
                            audioElement.style.display = 'none';
                            document.body.appendChild(audioElement);
                            console.log('‚úÖ Created audio element:', audioElement.id, 'muted:', audioElement.muted);
                        }

                        audioElement.srcObject = event.streams[0];

                        // Enable the audio mute button now that we have audio
                        const audioBtn = document.getElementById('audioBtn_' + peerId);
                        if (audioBtn) {
                            audioBtn.disabled = false;
                            const isMuted = peerAudioMuted[peerId];
                            audioBtn.innerHTML = isMuted ? 'üîá' : 'üîä';
                            audioBtn.title = isMuted ? 'Unmute this peer' : 'Mute this peer';
                            console.log('üîä Enabled audio button for peer:', peerId, 'muted:', isMuted);
                        }

                        // Try to play audio
                        audioElement.play().then(() => {
                            console.log('‚úÖ Audio playing from peer:', peerId);
                        }).catch(err => {
                            console.warn('‚ö†Ô∏è Audio autoplay blocked:', err.message);
                        });
                    }
                };

                pc.onconnectionstatechange = function() {
                    console.log('Peer', peerId, 'connection state:', pc.connectionState);

                    if (pc.connectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è Peer disconnected:', peerId, '- will attempt recovery');
                        // Mark connection as degraded but don't clean up yet
                        const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        if (videoWrapper) {
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge) {
                                badge.textContent = 'RECONNECTING';
                                badge.style.background = '#ffc107';
                            }
                        }

                        // Initialize recovery counter if not exists
                        if (!pc._recoveryAttempts) {
                            pc._recoveryAttempts = 0;
                        }

                        // Attempt recovery after a brief delay
                        if (pc._recoveryAttempts < 3) {
                            pc._recoveryAttempts++;
                            setTimeout(() => {
                                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                                    console.log(`üîÑ Recovery attempt ${pc._recoveryAttempts}/3 for peer:`, peerId);
                                    attemptIceRestart(pc, peerId);
                                }
                            }, 2000 * pc._recoveryAttempts); // Exponential backoff
                        } else {
                            console.error('‚ùå Max recovery attempts reached for peer:', peerId);
                            cleanupPeerConnection(peerId);
                        }

                    } else if (pc.connectionState === 'failed') {
                        console.error('‚ùå Peer connection failed:', peerId, '- attempting ICE restart');
                        attemptIceRestart(pc, peerId);

                    } else if (pc.connectionState === 'closed') {
                        console.log('üîí Peer connection closed:', peerId);
                        cleanupPeerConnection(peerId);

                    } else if (pc.connectionState === 'connected') {
                        // Reset recovery counter on successful connection
                        pc._recoveryAttempts = 0;
                        pc._isEstablished = true; // Mark as established for renegotiation
                        updatePeerCount();
                        console.log('‚úÖ Peer connected:', peerId);

                        // Update badge to show connected
                        const videoWrapper = document.getElementById('remoteVideo_' + peerId);
                        if (videoWrapper) {
                            const badge = videoWrapper.querySelector('.badge');
                            if (badge && badge.textContent === 'RECONNECTING') {
                                badge.textContent = 'LIVE';
                                badge.style.background = '#28a745';
                            }
                        }

                        // Monitor connection quality
                        if (!pc._qualityMonitor) {
                            monitorConnectionQuality(pc, peerId);
                        }
                    }
                };

                // Monitor ICE connection state for mobile issues
                pc.oniceconnectionstatechange = function() {
                    console.log('Peer', peerId, 'ICE connection state:', pc.iceConnectionState);
                    if (pc.iceConnectionState === 'failed') {
                        console.error('‚ùå ICE connection failed for peer:', peerId);
                    } else if (pc.iceConnectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è ICE disconnected for peer:', peerId);
                    } else if (pc.iceConnectionState === 'connected') {
                        console.log('‚úÖ ICE connected for peer:', peerId);
                    } else if (pc.iceConnectionState === 'completed') {
                        console.log('‚úÖ ICE gathering completed for peer:', peerId);
                    }
                };

                // Monitor ICE gathering state
                pc.onicegatheringstatechange = function() {
                    console.log('Peer', peerId, 'ICE gathering state:', pc.iceGatheringState);
                    if (pc.iceGatheringState === 'complete') {
                        console.log('‚úÖ ICE gathering complete for peer:', peerId);
                    }
                };

                // Monitor signaling state
                pc.onsignalingstatechange = function() {
                    console.log('Peer', peerId, 'signaling state:', pc.signalingState);
                    if (pc.signalingState === 'stable') {
                        console.log('‚úÖ Signaling stable for peer:', peerId);
                    } else if (pc.signalingState === 'closed') {
                        console.log('üîí Signaling closed for peer:', peerId);
                    }
                };

                // Monitor negotiation needed
                pc.onnegotiationneeded = async function() {
                    console.log('üîÑ Negotiation needed for peer:', peerId);
                    // Only handle if we're stable and this is a renegotiation
                    if (pc.signalingState === 'stable' && pc._isEstablished) {
                        try {
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            socket.emit(voiceOfferSocketEvent, {
                                offer: pc.localDescription,
                                to: peerId,
                                cameraName: myCameraName
                            });
                            console.log('üì§ Sent renegotiation offer to peer:', peerId);
                        } catch (err) {
                            console.error('‚ùå Renegotiation failed for peer:', peerId, err);
                        }
                    }
                };

                return pc;
            }

            async function handleOffer(data) {
                console.log('Received offer from:', data.from);

                // Store peer's camera name if provided
                if (data.cameraName) {
                    peerCameraNames[data.from] = data.cameraName;
                    console.log('üìù Stored camera name for', data.from, ':', data.cameraName);
                }

                const pc = createPeerConnection(data.from);

                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    console.log('‚úÖ Set remote description for offer from:', data.from);

                    // Process any pending ICE candidates
                    await processPendingIceCandidates(data.from);

                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);

                    socket.emit(voiceAnswerSocketEvent, {
                        answer: pc.localDescription,
                        to: data.from,
                        cameraName: myCameraName
                    });
                    console.log('üì§ Sent answer to:', data.from);
                } catch (error) {
                    console.error('‚ùå Error handling offer from:', data.from, error.message);
                    console.debug('Offer data:', data.offer);
                }
            }

            async function handleAnswer(data) {
                console.log('Received answer from:', data.from);

                // Store peer's camera name if provided
                if (data.cameraName) {
                    peerCameraNames[data.from] = data.cameraName;
                    console.log('üìù Stored camera name for', data.from, ':', data.cameraName);
                }

                const pc = peerConnections[data.from];
                if (pc) {
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        console.log('‚úÖ Set remote description for answer from:', data.from);

                        // Process any pending ICE candidates
                        await processPendingIceCandidates(data.from);
                    } catch (error) {
                        console.error('‚ùå Error handling answer from:', data.from, error.message);
                        console.debug('Answer data:', data.answer);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Received answer from unknown peer:', data.from);
                }
            }

            async function handleIceCandidate(data) {
                const pc = peerConnections[data.from];
                if (!pc || !data.candidate) return;

                // Validate candidate has required properties
                if (!data.candidate.candidate || data.candidate.candidate.trim() === '') {
                    console.warn('‚ö†Ô∏è Skipping invalid/empty ICE candidate from:', data.from);
                    return;
                }

                // If remote description not set yet, queue the candidate
                if (!pc.remoteDescription || !pc.remoteDescription.type) {
                    console.log('‚è∏Ô∏è Queueing ICE candidate from:', data.from, '(remote description not set)');
                    if (!pendingIceCandidates[data.from]) {
                        pendingIceCandidates[data.from] = [];
                    }
                    pendingIceCandidates[data.from].push(data.candidate);
                    return;
                }

                // Remote description is set, add candidate
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (error) {
                    // Safari can be strict about candidate format - log but don't crash
                    console.warn('‚ö†Ô∏è Failed to add ICE candidate from:', data.from, 'Error:', error.message);
                    console.debug('Candidate data:', data.candidate);
                }
            }

            async function processPendingIceCandidates(peerId) {
                const pc = peerConnections[peerId];
                const candidates = pendingIceCandidates[peerId];

                if (!pc || !candidates || candidates.length === 0) return;

                console.log('üîÑ Processing', candidates.length, 'pending ICE candidates for:', peerId);

                for (const candidate of candidates) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to add pending ICE candidate:', error.message);
                    }
                }

                // Clear the queue
                delete pendingIceCandidates[peerId];
                console.log('‚úÖ Processed all pending ICE candidates for:', peerId);
            }

            function handlePeerDisconnect(data) {
                console.log('Peer disconnected:', data.userId);

                // Clean up video element and monitors
                const videoWrapper = document.getElementById('remoteVideo_' + data.userId);
                if (videoWrapper) {
                    const video = videoWrapper.querySelector('video');
                    if (video) {
                        if (video._renderMonitor) {
                            clearInterval(video._renderMonitor);
                        }
                        if (video._diagInterval) {
                            clearInterval(video._diagInterval);
                        }
                    }
                    videoWrapper.remove();
                }

                // Clean up audio element
                const audioElement = document.getElementById('remoteAudio_' + data.userId);
                if (audioElement) {
                    audioElement.remove();
                }

                // Close and remove peer connection
                if (peerConnections[data.userId]) {
                    peerConnections[data.userId].close();
                    delete peerConnections[data.userId];
                }

                // Clean up pending ICE candidates
                if (pendingIceCandidates[data.userId]) {
                    delete pendingIceCandidates[data.userId];
                }

                // Clean up peer camera name
                if (peerCameraNames[data.userId]) {
                    delete peerCameraNames[data.userId];
                }

                // Clean up per-peer audio mute state
                if (peerAudioMuted[data.userId] !== undefined) {
                    delete peerAudioMuted[data.userId];
                }

                delete remoteCameraStreams[data.userId];
                updatePeerCount();
                updateEmptyState();
            }

            // Broadcast offer when new peer joins (always establish connection)
            socket.on(endpoint + 'cameracamera' + 'connect', function(data) {
                console.log('üîî New peer joined:', data.userId);

                // Only create connection if this is a different peer
                if (data.userId !== socket.id) {
                    // Glare resolution: only the peer with the lower ID creates the offer
                    // This prevents both peers from sending offers simultaneously when joining at the same time
                    const shouldCreateOffer = socket.id < data.userId;

                    console.log('Creating peer connection (camera:', isCameraEnabled, 'mic:', isMicEnabled, ')');
                    console.log('My camera name:', myCameraName || '(not set)');
                    console.log('Should create offer:', shouldCreateOffer, '(my ID:', socket.id, 'vs their ID:', data.userId, ')');

                    if (shouldCreateOffer) {
                        // Create peer connection (will add any enabled media tracks)
                        const pc = createPeerConnection(data.userId);

                        // Always create and send offer, even if we don't have media yet
                        // This establishes the connection, and media can be added later
                        pc.createOffer().then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                socket.emit(voiceOfferSocketEvent, {
                                    offer: pc.localDescription,
                                    to: data.userId,
                                    cameraName: myCameraName
                                });
                                console.log('üì§ Sent offer to new peer:', data.userId, 'with name:', myCameraName || '(default)');
                            })
                            .catch(err => {
                                console.error('‚ùå Error creating offer:', err);
                            });
                    } else {
                        console.log('‚è∏Ô∏è Waiting for offer from peer:', data.userId, '(they have lower ID)');
                        // Still create the peer connection so we're ready to receive their offer
                        createPeerConnection(data.userId);
                    }
                }
            });
        </script>

<footer style="text-align: center; padding: 20px; margin-top: 30px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: #999; font-size: 12px;">
    <p style="margin: 5px 0;">&copy; 2025 jaemzware llc</p>
    <p style="margin: 5px 0;"><a href="https://jaemzware.com" target="_blank" style="color: #4a9eff; text-decoration: none;">jaemzware.com</a></p>
    <p style="margin: 5px 0;"><a href="mailto:jaemzware@hotmail.com" style="color: #4a9eff; text-decoration: none;">jaemzware@hotmail.com</a></p>
</footer>
    </body>
</html>
